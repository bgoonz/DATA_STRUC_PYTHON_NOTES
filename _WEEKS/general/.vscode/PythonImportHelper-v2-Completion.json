[
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappop",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heappush",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "heapify",
        "importPath": "heapq",
        "description": "heapq",
        "isExtraImport": true,
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "sqrt",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "groupby",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "permutations",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "weekday",
        "importPath": "calendar",
        "description": "calendar",
        "isExtraImport": true,
        "detail": "calendar",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "kind": 2,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Search.binary_search",
        "description": "MAIN_DATA_STRUCTURES.Binary Search.binary_search",
        "peekOfCode": "def binary_search(input_array, value):\n    test_array = input_array\n    current_index = len(input_array) // 2\n    input_index = current_index\n    found_value = test_array[current_index]\n    while len(test_array) > 1 and found_value != value:\n        if found_value < value:\n            test_array = test_array[current_index:]\n            current_index = len(test_array) // 2\n            input_index += current_index",
        "detail": "MAIN_DATA_STRUCTURES.Binary Search.binary_search",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "kind": 2,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Search.binary_search",
        "description": "MAIN_DATA_STRUCTURES.Binary Search.binary_search",
        "peekOfCode": "def linear_search(a, x):\n    for i in range(len(a)):\n        if a[i] == x:\n            return i\n    return -1\n# compare naive algorithm linear search vs. binary search results\ndef stress_test(n, m):\n    test_cond = True\n    while test_cond:\n        a = []",
        "detail": "MAIN_DATA_STRUCTURES.Binary Search.binary_search",
        "documentation": {}
    },
    {
        "label": "stress_test",
        "kind": 2,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Search.binary_search",
        "description": "MAIN_DATA_STRUCTURES.Binary Search.binary_search",
        "peekOfCode": "def stress_test(n, m):\n    test_cond = True\n    while test_cond:\n        a = []\n        for i in range(n):\n            a.append(random.randint(0, 10 ** 9))\n        a.sort()\n        for i in range(m):\n            b = random.randint(0, n - 1)\n            print([linear_search(a, a[b]), binary_search(a, a[b])])",
        "detail": "MAIN_DATA_STRUCTURES.Binary Search.binary_search",
        "documentation": {}
    },
    {
        "label": "binary_search_recursive",
        "kind": 2,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Search.recursive_binary_search",
        "description": "MAIN_DATA_STRUCTURES.Binary Search.recursive_binary_search",
        "peekOfCode": "def binary_search_recursive(a, x, left=0, right=(len(a)-1)):\n\"\"\"Recursive Binary Search algorithm implemented using list indexing\"\"\"\n    index = (left+right)//2\n    if a[index]==x:\n        return index\n    elif x>(a[right]) or x<a[left]: # first case where x is not in the list!\n        return -1\n    elif left==right: # case where search is complete and no value x not found\n        return -1\n    elif left==right-1: # case where there are only two numbers left, check both!",
        "detail": "MAIN_DATA_STRUCTURES.Binary Search.recursive_binary_search",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Trees.binary_search_tree",
        "description": "MAIN_DATA_STRUCTURES.Binary Trees.binary_search_tree",
        "peekOfCode": "class Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\nclass BST(object):\n    def __init__(self, root):\n        self.root = Node(root)\n    def insert(self, new_val):\n        if(self.root.left==None):",
        "detail": "MAIN_DATA_STRUCTURES.Binary Trees.binary_search_tree",
        "documentation": {}
    },
    {
        "label": "BST",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Trees.binary_search_tree",
        "description": "MAIN_DATA_STRUCTURES.Binary Trees.binary_search_tree",
        "peekOfCode": "class BST(object):\n    def __init__(self, root):\n        self.root = Node(root)\n    def insert(self, new_val):\n        if(self.root.left==None):\n            if(self.root.value>new_val):\n                self.root.left = Node(new_val)\n        elif(self.root.right==None):\n            if(self.root.value<new_val):\n                self.root.right = Node(new_val)",
        "detail": "MAIN_DATA_STRUCTURES.Binary Trees.binary_search_tree",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Trees.binary_search_tree",
        "description": "MAIN_DATA_STRUCTURES.Binary Trees.binary_search_tree",
        "peekOfCode": "tree = BST(4)\n# Insert elements\ntree.insert(2)\ntree.insert(1)\ntree.insert(3)\ntree.insert(5)\n# Check search\n# Should be True\nprint tree.search(4)\n# Should be False",
        "detail": "MAIN_DATA_STRUCTURES.Binary Trees.binary_search_tree",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "description": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "peekOfCode": "class Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\nclass BinaryTree(object):\n    def __init__(self, root):\n        self.root = Node(root)\n    def preorder_search(self, start, find_val):\n        \"\"\"Helper method - use this to create a",
        "detail": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "BinaryTree",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "description": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "peekOfCode": "class BinaryTree(object):\n    def __init__(self, root):\n        self.root = Node(root)\n    def preorder_search(self, start, find_val):\n        \"\"\"Helper method - use this to create a\n        recursive search solution.\"\"\"\n        if start.value == find_val:\n            return True\n        if start.left != None:\n            left_result = self.preorder_search(start.left, find_val)",
        "detail": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "description": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "peekOfCode": "tree = BinaryTree(1)\ntree.root.left = Node(2)\ntree.root.right = Node(3)\ntree.root.left.left = Node(4)\ntree.root.left.right = Node(5)\n# Test search\n# Should be True\nprint(tree.search(4))\n# Should be False\nprint(tree.search(6))",
        "detail": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "tree.root.left",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "description": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "peekOfCode": "tree.root.left = Node(2)\ntree.root.right = Node(3)\ntree.root.left.left = Node(4)\ntree.root.left.right = Node(5)\n# Test search\n# Should be True\nprint(tree.search(4))\n# Should be False\nprint(tree.search(6))\n# Test print_tree",
        "detail": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "tree.root.right",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "description": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "peekOfCode": "tree.root.right = Node(3)\ntree.root.left.left = Node(4)\ntree.root.left.right = Node(5)\n# Test search\n# Should be True\nprint(tree.search(4))\n# Should be False\nprint(tree.search(6))\n# Test print_tree\n# Should be 1-2-4-5-3",
        "detail": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "tree.root.left.left",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "description": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "peekOfCode": "tree.root.left.left = Node(4)\ntree.root.left.right = Node(5)\n# Test search\n# Should be True\nprint(tree.search(4))\n# Should be False\nprint(tree.search(6))\n# Test print_tree\n# Should be 1-2-4-5-3\nprint(tree.print_tree())",
        "detail": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "tree.root.left.right",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "description": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "peekOfCode": "tree.root.left.right = Node(5)\n# Test search\n# Should be True\nprint(tree.search(4))\n# Should be False\nprint(tree.search(6))\n# Test print_tree\n# Should be 1-2-4-5-3\nprint(tree.print_tree())",
        "detail": "MAIN_DATA_STRUCTURES.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "description": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "peekOfCode": "class Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.edges = []\nclass Edge(object):\n    def __init__(self, value, node_from, node_to):\n        self.value = value\n        self.node_from = node_from\n        self.node_to = node_to\nclass Graph(object):",
        "detail": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "documentation": {}
    },
    {
        "label": "Edge",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "description": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "peekOfCode": "class Edge(object):\n    def __init__(self, value, node_from, node_to):\n        self.value = value\n        self.node_from = node_from\n        self.node_to = node_to\nclass Graph(object):\n    def __init__(self, nodes=[], edges=[]):\n        self.nodes = nodes\n        self.edges = edges\n    def insert_node(self, new_node_val):",
        "detail": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "description": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "peekOfCode": "class Graph(object):\n    def __init__(self, nodes=[], edges=[]):\n        self.nodes = nodes\n        self.edges = edges\n    def insert_node(self, new_node_val):\n        new_node = Node(new_node_val)\n        self.nodes.append(new_node)\n    def insert_edge(self, new_edge_val, node_from_val, node_to_val):\n        from_found = None\n        to_found = None",
        "detail": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "description": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "peekOfCode": "graph = Graph()\ngraph.insert_edge(100, 1, 2)\ngraph.insert_edge(101, 1, 3)\ngraph.insert_edge(102, 1, 4)\ngraph.insert_edge(103, 3, 4)\n# Should be [(100, 1, 2), (101, 1, 3), (102, 1, 4), (103, 3, 4)]\nprint(graph.get_edge_list())\n# Should be [None, [(2, 100), (3, 101), (4, 102)], None, [(4, 103)], None]\nprint(graph.get_adjacency_list())\n# Should be [[0, 0, 0, 0, 0], [0, 0, 100, 101, 102], [0, 0, 0, 0, 0], [0, 0, 0, 0, 103], [0, 0, 0, 0, 0]]",
        "detail": "MAIN_DATA_STRUCTURES.Graphs.directed_graph",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "description": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "peekOfCode": "class Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.edges = []\n        self.visited = False\nclass Edge(object):\n    def __init__(self, value, node_from, node_to):\n        self.value = value\n        self.node_from = node_from\n        self.node_to = node_to",
        "detail": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "documentation": {}
    },
    {
        "label": "Edge",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "description": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "peekOfCode": "class Edge(object):\n    def __init__(self, value, node_from, node_to):\n        self.value = value\n        self.node_from = node_from\n        self.node_to = node_to\n# You only need to change code with docs strings that have TODO.\n# Specifically: Graph.dfs_helper and Graph.bfs\n# New methods have been added to associate node numbers with names\n# Specifically: Graph.set_node_names\n# and the methods ending in \"_names\" which will print names instead",
        "detail": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "description": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "peekOfCode": "class Graph(object):\n    def __init__(self, nodes=None, edges=None):\n        self.nodes = nodes or []\n        self.edges = edges or []\n        self.node_names = []\n        self._node_map = {}\n    def set_node_names(self, names):\n        \"\"\"The Nth name in names should correspond to node number N.\n        Node numbers are 0 based (starting at 0).\n        \"\"\"",
        "detail": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "description": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "peekOfCode": "graph = Graph()\n# You do not need to change anything below this line.\n# You only need to implement Graph.dfs_helper and Graph.bfs\ngraph.set_node_names(\n    (\n        \"Mountain View\",  # 0\n        \"San Francisco\",  # 1\n        \"London\",  # 2\n        \"Shanghai\",  # 3\n        \"Berlin\",  # 4",
        "detail": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "documentation": {}
    },
    {
        "label": "pp",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "description": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "peekOfCode": "pp = pprint.PrettyPrinter(indent=2)\nprint(\"Edge List\")\npp.pprint(graph.get_edge_list_names())\nprint(\"\\nAdjacency List\")\npp.pprint(graph.get_adjacency_list_names())\nprint(\"\\nAdjacency Matrix\")\npp.pprint(graph.get_adjacency_matrix())\nprint(\"\\nDepth First Search\")\npp.pprint(graph.dfs_names(2))\n# Should print:",
        "detail": "MAIN_DATA_STRUCTURES.Graphs.graph_traversal",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Hash Tables.HashTable",
        "description": "MAIN_DATA_STRUCTURES.Hash Tables.HashTable",
        "peekOfCode": "class HashTable(object):\n    def __init__(self):\n        self.table = [None]*10000\n    def store(self, string):\n        \"\"\"Input a string that's stored in\n        the table.\"\"\"\n        index = self.calculate_hash_value(string)\n        if(self.lookup(string)==-1):\n            self.table[index] = [string]\n        else:",
        "detail": "MAIN_DATA_STRUCTURES.Hash Tables.HashTable",
        "documentation": {}
    },
    {
        "label": "hash_table",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Hash Tables.HashTable",
        "description": "MAIN_DATA_STRUCTURES.Hash Tables.HashTable",
        "peekOfCode": "hash_table = HashTable()\n# Test calculate_hash_value\n# Should be 8568\nprint hash_table.calculate_hash_value('UDACITY')\n# Test lookup edge case\n# Should be -1\nprint hash_table.lookup('UDACITY')\n# Test store\nhash_table.store('UDACITY')\n# Should be 8568",
        "detail": "MAIN_DATA_STRUCTURES.Hash Tables.HashTable",
        "documentation": {}
    },
    {
        "label": "Element",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "description": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "peekOfCode": "class Element(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None\nclass LinkedList(object):\n    def __init__(self, head=None):\n        self.head = head\n    def append(self, new_element):\n        current = self.head\n        if self.head:",
        "detail": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "LinkedList",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "description": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "peekOfCode": "class LinkedList(object):\n    def __init__(self, head=None):\n        self.head = head\n    def append(self, new_element):\n        current = self.head\n        if self.head:\n            while current.next:\n                current = current.next\n            current.next = new_element\n        else:",
        "detail": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "e1",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "description": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "peekOfCode": "e1 = Element(1)\ne2 = Element(2)\ne3 = Element(3)\ne4 = Element(4)\n# Start setting up a LinkedList\nll = LinkedList(e1)\nll.append(e2)\nll.append(e3)\n# Test get_position\n# Should print 3",
        "detail": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "e2",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "description": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "peekOfCode": "e2 = Element(2)\ne3 = Element(3)\ne4 = Element(4)\n# Start setting up a LinkedList\nll = LinkedList(e1)\nll.append(e2)\nll.append(e3)\n# Test get_position\n# Should print 3\nprint ll.head.next.next.value",
        "detail": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "e3",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "description": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "peekOfCode": "e3 = Element(3)\ne4 = Element(4)\n# Start setting up a LinkedList\nll = LinkedList(e1)\nll.append(e2)\nll.append(e3)\n# Test get_position\n# Should print 3\nprint ll.head.next.next.value\n# Should also print 3",
        "detail": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "e4",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "description": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "peekOfCode": "e4 = Element(4)\n# Start setting up a LinkedList\nll = LinkedList(e1)\nll.append(e2)\nll.append(e3)\n# Test get_position\n# Should print 3\nprint ll.head.next.next.value\n# Should also print 3\nprint ll.get_position(3).value",
        "detail": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "ll",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "description": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "peekOfCode": "ll = LinkedList(e1)\nll.append(e2)\nll.append(e3)\n# Test get_position\n# Should print 3\nprint ll.head.next.next.value\n# Should also print 3\nprint ll.get_position(3).value\n# Test insert\nll.insert(e4,3)",
        "detail": "MAIN_DATA_STRUCTURES.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Queues.Queues_Class_Practice",
        "description": "MAIN_DATA_STRUCTURES.Queues.Queues_Class_Practice",
        "peekOfCode": "class Queue:\n    def __init__(self, head=None):\n        self.storage = [head]\n    def enqueue(self, new_element):\n        if(self.storage):\n            self.storage.append(new_element)\n        else:\n            self.storage = [new_element]\n        return new_element\n    def peek(self):",
        "detail": "MAIN_DATA_STRUCTURES.Queues.Queues_Class_Practice",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Queues.Queues_Class_Practice",
        "description": "MAIN_DATA_STRUCTURES.Queues.Queues_Class_Practice",
        "peekOfCode": "q = Queue(1)\nq.enqueue(2)\nq.enqueue(3)\n# Test peek\n# Should be 1\nprint q.peek()\n# Test dequeue\n# Should be 1\nprint q.dequeue()\n# Test enqueue",
        "detail": "MAIN_DATA_STRUCTURES.Queues.Queues_Class_Practice",
        "documentation": {}
    },
    {
        "label": "get_fib",
        "kind": 2,
        "importPath": "MAIN_DATA_STRUCTURES.Recursion.fibonacci",
        "description": "MAIN_DATA_STRUCTURES.Recursion.fibonacci",
        "peekOfCode": "def get_fib(position):\n    output = 0\n    if(position==0):\n        return output\n    if(position==1):\n        return position\n    else:\n        output += get_fib(position-1)+get_fib(position-2)\n        return output\n# Test cases",
        "detail": "MAIN_DATA_STRUCTURES.Recursion.fibonacci",
        "documentation": {}
    },
    {
        "label": "mergeSort",
        "kind": 2,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.mergesort_from_book",
        "description": "MAIN_DATA_STRUCTURES.Sorting.mergesort_from_book",
        "peekOfCode": "def mergeSort(list):\n    # Determine whether the list is broken into\n    # individual pieces.\n    if len(list) < 2:\n        return list\n    # Find the middle of the list.\n    middle = len(list) // 2\n    # Break the list into two pieces.\n    left = mergeSort(list[:middle])\n    right = mergeSort(list[middle:])",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.mergesort_from_book",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.mergesort_from_book",
        "description": "MAIN_DATA_STRUCTURES.Sorting.mergesort_from_book",
        "peekOfCode": "def merge(left, right):\n    # When the left side or the right side is empty,\n    # it means that this is an individual item and is\n    # already sorted.\n    if not len(left):\n        return left\n    if not len(right):\n        return right\n    # Define variables used to merge the two pieces.\n    result = []",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.mergesort_from_book",
        "documentation": {}
    },
    {
        "label": "quicksort",
        "kind": 2,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "description": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "peekOfCode": "def quicksort(array):\n    if len(array) <= 1:\n        return array\n    else:\n        pivot = array[-1]\n        n = 0\n        i = 0\n        while n < len(array) - i:\n            # print(array)\n            # print(n)",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "description": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "peekOfCode": "test = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]\ntimes = []\nfor i in range(1000):\n    start = time.clock()\n    quicksort(test)\n    end = time.clock()\n    times.append(end - start)\naverage = sum(times) / len(times)\nprint(average)",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "documentation": {}
    },
    {
        "label": "times",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "description": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "peekOfCode": "times = []\nfor i in range(1000):\n    start = time.clock()\n    quicksort(test)\n    end = time.clock()\n    times.append(end - start)\naverage = sum(times) / len(times)\nprint(average)",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "documentation": {}
    },
    {
        "label": "average",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "description": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "peekOfCode": "average = sum(times) / len(times)\nprint(average)",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.quicksort",
        "documentation": {}
    },
    {
        "label": "quicksort_equal_elements",
        "kind": 2,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.quicksort_for_equal_elems",
        "description": "MAIN_DATA_STRUCTURES.Sorting.quicksort_for_equal_elems",
        "peekOfCode": "def quicksort_equal_elements(s):\n    \"\"\"Quicksort from finxter modified to add all elements equal to the pivot\n    directly after the pivot, so that quicksort performs faster for cases\n    where there are many identical elements in the array to be sorted (e.g.\n    there are only 2 values for all elements, or 1 unique value in a large\n    array, etc.)\"\"\"\n    if len(s) < 2:\n        return s\n    else:\n        # upgraded to work for sets with multiple identical numbers!",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.quicksort_for_equal_elems",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 2,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "description": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "peekOfCode": "def A(s):\n    if len(s) < 2:\n        return s\n    else:\n        return (\n            A([x for x in s[1:] if x < s[0]])\n            + [s[0]]\n            + A([x for x in s[1:] if x >= s[0]])\n        )\n# start = time.clock()",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "description": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "peekOfCode": "test = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]\ntimes = []\nfor i in range(1000):\n    start = time.clock()\n    A(test)\n    end = time.clock()\n    times.append(end - start)\naverage = sum(times) / len(times)\nprint(average)",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "documentation": {}
    },
    {
        "label": "times",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "description": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "peekOfCode": "times = []\nfor i in range(1000):\n    start = time.clock()\n    A(test)\n    end = time.clock()\n    times.append(end - start)\naverage = sum(times) / len(times)\nprint(average)",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "documentation": {}
    },
    {
        "label": "average",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "description": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "peekOfCode": "average = sum(times) / len(times)\nprint(average)",
        "detail": "MAIN_DATA_STRUCTURES.Sorting.quicksort_from_finxter",
        "documentation": {}
    },
    {
        "label": "Element",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "description": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "peekOfCode": "class Element(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None\nclass LinkedList(object):\n    def __init__(self, head=None):\n        self.head = head\n    def append(self, new_element):\n        current = self.head\n        if self.head:",
        "detail": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "LinkedList",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "description": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "peekOfCode": "class LinkedList(object):\n    def __init__(self, head=None):\n        self.head = head\n    def append(self, new_element):\n        current = self.head\n        if self.head:\n            while current.next:\n                current = current.next\n            current.next = new_element\n        else:",
        "detail": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "description": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "peekOfCode": "class Stack(object):\n    def __init__(self,top=None):\n        self.ll = LinkedList(top)\n    def push(self, new_element):\n        \"Push (add) a new element onto the top of the stack\"\n        former = self.ll.head\n        new_element.next = former\n        self.ll.head = new_element\n        pass\n    def pop(self):",
        "detail": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "e1",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "description": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "peekOfCode": "e1 = Element(1)\ne2 = Element(2)\ne3 = Element(3)\ne4 = Element(4)\n# Start setting up a Stack\nstack = Stack(e1)\n# Test stack functionality\nstack.push(e2)\nstack.push(e3)\nprint stack.pop().value",
        "detail": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "e2",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "description": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "peekOfCode": "e2 = Element(2)\ne3 = Element(3)\ne4 = Element(4)\n# Start setting up a Stack\nstack = Stack(e1)\n# Test stack functionality\nstack.push(e2)\nstack.push(e3)\nprint stack.pop().value\nprint stack.pop().value",
        "detail": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "e3",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "description": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "peekOfCode": "e3 = Element(3)\ne4 = Element(4)\n# Start setting up a Stack\nstack = Stack(e1)\n# Test stack functionality\nstack.push(e2)\nstack.push(e3)\nprint stack.pop().value\nprint stack.pop().value\nprint stack.pop().value",
        "detail": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "e4",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "description": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "peekOfCode": "e4 = Element(4)\n# Start setting up a Stack\nstack = Stack(e1)\n# Test stack functionality\nstack.push(e2)\nstack.push(e3)\nprint stack.pop().value\nprint stack.pop().value\nprint stack.pop().value\nprint stack.pop()",
        "detail": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "stack",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "description": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "peekOfCode": "stack = Stack(e1)\n# Test stack functionality\nstack.push(e2)\nstack.push(e3)\nprint stack.pop().value\nprint stack.pop().value\nprint stack.pop().value\nprint stack.pop()\nstack.push(e4)\nprint stack.pop().value",
        "detail": "MAIN_DATA_STRUCTURES.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.AVL",
        "description": "MAIN_DATA_STRUCTURES.AVL",
        "peekOfCode": "class Node:\n    def __init__(self, data, parent):\n        self.data = data\n        self.parent = parent\n        self.right_node = None\n        self.left_node = None\n        self.height = 0\nclass AVLTree:\n    def __init__(self):\n        self.root = None",
        "detail": "MAIN_DATA_STRUCTURES.AVL",
        "documentation": {}
    },
    {
        "label": "AVLTree",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.AVL",
        "description": "MAIN_DATA_STRUCTURES.AVL",
        "peekOfCode": "class AVLTree:\n    def __init__(self):\n        self.root = None\n    def remove(self, data):\n        if self.root:\n            self.remove_node(data, self.root)\n    def insert(self, data):\n        if self.root is None:\n            self.root = Node(data, None)\n        else:",
        "detail": "MAIN_DATA_STRUCTURES.AVL",
        "documentation": {}
    },
    {
        "label": "avl",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.AVL",
        "description": "MAIN_DATA_STRUCTURES.AVL",
        "peekOfCode": "avl = AVLTree()\navl.insert(5)\navl.insert(3)\navl.insert(6)\navl.insert(1)\navl.remove(6)\navl.traverse()",
        "detail": "MAIN_DATA_STRUCTURES.AVL",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.binary-search-tree",
        "description": "MAIN_DATA_STRUCTURES.binary-search-tree",
        "peekOfCode": "class Node:\n    def __init__(self, data, parent):\n        self.data = data\n        self.leftChild = None\n        self.rightChild = None\n        self.parent = parent\n# create the tree class and initialize the root node to none\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None",
        "detail": "MAIN_DATA_STRUCTURES.binary-search-tree",
        "documentation": {}
    },
    {
        "label": "BinarySearchTree",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.binary-search-tree",
        "description": "MAIN_DATA_STRUCTURES.binary-search-tree",
        "peekOfCode": "class BinarySearchTree:\n    def __init__(self):\n        self.root = None\n    \"\"\"\n    Binary search tree methods (insert)\n    \"\"\"\n    # O(logN) if the tree is balanced if not balanced O(N)\n    # function to get the data\n    def insert(self, data):\n        # check to see if the root is empty",
        "detail": "MAIN_DATA_STRUCTURES.binary-search-tree",
        "documentation": {}
    },
    {
        "label": "bst",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.binary-search-tree",
        "description": "MAIN_DATA_STRUCTURES.binary-search-tree",
        "peekOfCode": "bst = BinarySearchTree()\nbst.insert(10)\nbst.insert(5)\nbst.insert(-5)\nbst.insert(1)\nbst.insert(99)\nbst.insert(34)\nbst.remove(99)\n# print the max node of the tree passing in the root\nprint(\"max node:\", bst.get_max(bst.root))",
        "detail": "MAIN_DATA_STRUCTURES.binary-search-tree",
        "documentation": {}
    },
    {
        "label": "heap",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.built-in-heaps",
        "description": "MAIN_DATA_STRUCTURES.built-in-heaps",
        "peekOfCode": "heap = []\nnums = [12, 3, -2, 6, 4, 8, 9]\n# for num in nums:\n#     heappush(heap, num)\n# while heap:\n#     print(heappop(heap))\nheapify(nums)\nprint(nums)",
        "detail": "MAIN_DATA_STRUCTURES.built-in-heaps",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.built-in-heaps",
        "description": "MAIN_DATA_STRUCTURES.built-in-heaps",
        "peekOfCode": "nums = [12, 3, -2, 6, 4, 8, 9]\n# for num in nums:\n#     heappush(heap, num)\n# while heap:\n#     print(heappop(heap))\nheapify(nums)\nprint(nums)",
        "detail": "MAIN_DATA_STRUCTURES.built-in-heaps",
        "documentation": {}
    },
    {
        "label": "Edge",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "class Edge(object):\n    def __init__(self, weight, startVertex, targetVertex):\n        self.weight = weight\n        self.startVertex = startVertex\n        self.targetVertex = targetVertex\nclass Node(object):\n    def __init__(self, name):\n        self.name = name\n        self.visited = False\n        self.predecessor = None",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "class Node(object):\n    def __init__(self, name):\n        self.name = name\n        self.visited = False\n        self.predecessor = None\n        self.adjacenciesList = []\n        self.minDistance = sys.maxsize\n    def __cmp__(self, otherVertex):\n        return self.cmp(self.minDistance, otherVertex.minDistance)\n    def __lt__(self, other):",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "Algorithm",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "class Algorithm(object):\n    def calculateShortestPath(self, vertexList, startVertex):\n        q = []\n        startVertex.minDistance = 0\n        heapq.heappush(q, startVertex)\n        while q:\n            actualVertex = heapq.heappop(q)\n            for edge in actualVertex.adjacenciesList:\n                u = edge.startVertex\n                v = edge.targetVertex",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "node1",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "node1 = Node(\"A\")\nnode2 = Node(\"B\")\nnode3 = Node(\"C\")\nnode4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode6 = Node(\"F\")\nnode7 = Node(\"G\")\nnode8 = Node(\"H\")\nedge1 = Edge(5, node1, node2)\nedge2 = Edge(8, node1, node8)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "node2",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "node2 = Node(\"B\")\nnode3 = Node(\"C\")\nnode4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode6 = Node(\"F\")\nnode7 = Node(\"G\")\nnode8 = Node(\"H\")\nedge1 = Edge(5, node1, node2)\nedge2 = Edge(8, node1, node8)\nedge3 = Edge(9, node1, node5)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "node3",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "node3 = Node(\"C\")\nnode4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode6 = Node(\"F\")\nnode7 = Node(\"G\")\nnode8 = Node(\"H\")\nedge1 = Edge(5, node1, node2)\nedge2 = Edge(8, node1, node8)\nedge3 = Edge(9, node1, node5)\nedge4 = Edge(15, node2, node4)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "node4",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "node4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode6 = Node(\"F\")\nnode7 = Node(\"G\")\nnode8 = Node(\"H\")\nedge1 = Edge(5, node1, node2)\nedge2 = Edge(8, node1, node8)\nedge3 = Edge(9, node1, node5)\nedge4 = Edge(15, node2, node4)\nedge5 = Edge(12, node2, node3)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "node5",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "node5 = Node(\"E\")\nnode6 = Node(\"F\")\nnode7 = Node(\"G\")\nnode8 = Node(\"H\")\nedge1 = Edge(5, node1, node2)\nedge2 = Edge(8, node1, node8)\nedge3 = Edge(9, node1, node5)\nedge4 = Edge(15, node2, node4)\nedge5 = Edge(12, node2, node3)\nedge6 = Edge(4, node2, node8)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "node6",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "node6 = Node(\"F\")\nnode7 = Node(\"G\")\nnode8 = Node(\"H\")\nedge1 = Edge(5, node1, node2)\nedge2 = Edge(8, node1, node8)\nedge3 = Edge(9, node1, node5)\nedge4 = Edge(15, node2, node4)\nedge5 = Edge(12, node2, node3)\nedge6 = Edge(4, node2, node8)\nedge7 = Edge(7, node8, node3)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "node7",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "node7 = Node(\"G\")\nnode8 = Node(\"H\")\nedge1 = Edge(5, node1, node2)\nedge2 = Edge(8, node1, node8)\nedge3 = Edge(9, node1, node5)\nedge4 = Edge(15, node2, node4)\nedge5 = Edge(12, node2, node3)\nedge6 = Edge(4, node2, node8)\nedge7 = Edge(7, node8, node3)\nedge8 = Edge(6, node8, node6)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "node8",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "node8 = Node(\"H\")\nedge1 = Edge(5, node1, node2)\nedge2 = Edge(8, node1, node8)\nedge3 = Edge(9, node1, node5)\nedge4 = Edge(15, node2, node4)\nedge5 = Edge(12, node2, node3)\nedge6 = Edge(4, node2, node8)\nedge7 = Edge(7, node8, node3)\nedge8 = Edge(6, node8, node6)\nedge9 = Edge(5, node5, node8)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge1",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge1 = Edge(5, node1, node2)\nedge2 = Edge(8, node1, node8)\nedge3 = Edge(9, node1, node5)\nedge4 = Edge(15, node2, node4)\nedge5 = Edge(12, node2, node3)\nedge6 = Edge(4, node2, node8)\nedge7 = Edge(7, node8, node3)\nedge8 = Edge(6, node8, node6)\nedge9 = Edge(5, node5, node8)\nedge10 = Edge(4, node5, node6)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge2",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge2 = Edge(8, node1, node8)\nedge3 = Edge(9, node1, node5)\nedge4 = Edge(15, node2, node4)\nedge5 = Edge(12, node2, node3)\nedge6 = Edge(4, node2, node8)\nedge7 = Edge(7, node8, node3)\nedge8 = Edge(6, node8, node6)\nedge9 = Edge(5, node5, node8)\nedge10 = Edge(4, node5, node6)\nedge11 = Edge(20, node5, node7)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge3",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge3 = Edge(9, node1, node5)\nedge4 = Edge(15, node2, node4)\nedge5 = Edge(12, node2, node3)\nedge6 = Edge(4, node2, node8)\nedge7 = Edge(7, node8, node3)\nedge8 = Edge(6, node8, node6)\nedge9 = Edge(5, node5, node8)\nedge10 = Edge(4, node5, node6)\nedge11 = Edge(20, node5, node7)\nedge12 = Edge(1, node6, node3)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge4",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge4 = Edge(15, node2, node4)\nedge5 = Edge(12, node2, node3)\nedge6 = Edge(4, node2, node8)\nedge7 = Edge(7, node8, node3)\nedge8 = Edge(6, node8, node6)\nedge9 = Edge(5, node5, node8)\nedge10 = Edge(4, node5, node6)\nedge11 = Edge(20, node5, node7)\nedge12 = Edge(1, node6, node3)\nedge13 = Edge(13, node6, node7)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge5",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge5 = Edge(12, node2, node3)\nedge6 = Edge(4, node2, node8)\nedge7 = Edge(7, node8, node3)\nedge8 = Edge(6, node8, node6)\nedge9 = Edge(5, node5, node8)\nedge10 = Edge(4, node5, node6)\nedge11 = Edge(20, node5, node7)\nedge12 = Edge(1, node6, node3)\nedge13 = Edge(13, node6, node7)\nedge14 = Edge(3, node3, node4)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge6",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge6 = Edge(4, node2, node8)\nedge7 = Edge(7, node8, node3)\nedge8 = Edge(6, node8, node6)\nedge9 = Edge(5, node5, node8)\nedge10 = Edge(4, node5, node6)\nedge11 = Edge(20, node5, node7)\nedge12 = Edge(1, node6, node3)\nedge13 = Edge(13, node6, node7)\nedge14 = Edge(3, node3, node4)\nedge15 = Edge(11, node3, node7)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge7",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge7 = Edge(7, node8, node3)\nedge8 = Edge(6, node8, node6)\nedge9 = Edge(5, node5, node8)\nedge10 = Edge(4, node5, node6)\nedge11 = Edge(20, node5, node7)\nedge12 = Edge(1, node6, node3)\nedge13 = Edge(13, node6, node7)\nedge14 = Edge(3, node3, node4)\nedge15 = Edge(11, node3, node7)\nedge16 = Edge(9, node4, node7)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge8",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge8 = Edge(6, node8, node6)\nedge9 = Edge(5, node5, node8)\nedge10 = Edge(4, node5, node6)\nedge11 = Edge(20, node5, node7)\nedge12 = Edge(1, node6, node3)\nedge13 = Edge(13, node6, node7)\nedge14 = Edge(3, node3, node4)\nedge15 = Edge(11, node3, node7)\nedge16 = Edge(9, node4, node7)\nnode1.adjacenciesList.append(edge1)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge9",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge9 = Edge(5, node5, node8)\nedge10 = Edge(4, node5, node6)\nedge11 = Edge(20, node5, node7)\nedge12 = Edge(1, node6, node3)\nedge13 = Edge(13, node6, node7)\nedge14 = Edge(3, node3, node4)\nedge15 = Edge(11, node3, node7)\nedge16 = Edge(9, node4, node7)\nnode1.adjacenciesList.append(edge1)\nnode1.adjacenciesList.append(edge2)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge10",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge10 = Edge(4, node5, node6)\nedge11 = Edge(20, node5, node7)\nedge12 = Edge(1, node6, node3)\nedge13 = Edge(13, node6, node7)\nedge14 = Edge(3, node3, node4)\nedge15 = Edge(11, node3, node7)\nedge16 = Edge(9, node4, node7)\nnode1.adjacenciesList.append(edge1)\nnode1.adjacenciesList.append(edge2)\nnode1.adjacenciesList.append(edge3)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge11",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge11 = Edge(20, node5, node7)\nedge12 = Edge(1, node6, node3)\nedge13 = Edge(13, node6, node7)\nedge14 = Edge(3, node3, node4)\nedge15 = Edge(11, node3, node7)\nedge16 = Edge(9, node4, node7)\nnode1.adjacenciesList.append(edge1)\nnode1.adjacenciesList.append(edge2)\nnode1.adjacenciesList.append(edge3)\nnode2.adjacenciesList.append(edge4)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge12",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge12 = Edge(1, node6, node3)\nedge13 = Edge(13, node6, node7)\nedge14 = Edge(3, node3, node4)\nedge15 = Edge(11, node3, node7)\nedge16 = Edge(9, node4, node7)\nnode1.adjacenciesList.append(edge1)\nnode1.adjacenciesList.append(edge2)\nnode1.adjacenciesList.append(edge3)\nnode2.adjacenciesList.append(edge4)\nnode2.adjacenciesList.append(edge5)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge13",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge13 = Edge(13, node6, node7)\nedge14 = Edge(3, node3, node4)\nedge15 = Edge(11, node3, node7)\nedge16 = Edge(9, node4, node7)\nnode1.adjacenciesList.append(edge1)\nnode1.adjacenciesList.append(edge2)\nnode1.adjacenciesList.append(edge3)\nnode2.adjacenciesList.append(edge4)\nnode2.adjacenciesList.append(edge5)\nnode2.adjacenciesList.append(edge6)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge14",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge14 = Edge(3, node3, node4)\nedge15 = Edge(11, node3, node7)\nedge16 = Edge(9, node4, node7)\nnode1.adjacenciesList.append(edge1)\nnode1.adjacenciesList.append(edge2)\nnode1.adjacenciesList.append(edge3)\nnode2.adjacenciesList.append(edge4)\nnode2.adjacenciesList.append(edge5)\nnode2.adjacenciesList.append(edge6)\nnode8.adjacenciesList.append(edge7)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge15",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge15 = Edge(11, node3, node7)\nedge16 = Edge(9, node4, node7)\nnode1.adjacenciesList.append(edge1)\nnode1.adjacenciesList.append(edge2)\nnode1.adjacenciesList.append(edge3)\nnode2.adjacenciesList.append(edge4)\nnode2.adjacenciesList.append(edge5)\nnode2.adjacenciesList.append(edge6)\nnode8.adjacenciesList.append(edge7)\nnode8.adjacenciesList.append(edge8)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "edge16",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "edge16 = Edge(9, node4, node7)\nnode1.adjacenciesList.append(edge1)\nnode1.adjacenciesList.append(edge2)\nnode1.adjacenciesList.append(edge3)\nnode2.adjacenciesList.append(edge4)\nnode2.adjacenciesList.append(edge5)\nnode2.adjacenciesList.append(edge6)\nnode8.adjacenciesList.append(edge7)\nnode8.adjacenciesList.append(edge8)\nnode5.adjacenciesList.append(edge9)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "vertexList",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "vertexList = (node1, node2, node3, node4, node5, node6, node7, node8)\nalgorithm = Algorithm()\nalgorithm.calculateShortestPath(vertexList, node1)\nalgorithm.getShortestPathTo(node4)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "algorithm",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.dijkstra",
        "description": "MAIN_DATA_STRUCTURES.dijkstra",
        "peekOfCode": "algorithm = Algorithm()\nalgorithm.calculateShortestPath(vertexList, node1)\nalgorithm.getShortestPathTo(node4)",
        "detail": "MAIN_DATA_STRUCTURES.dijkstra",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.graph-bfs",
        "description": "MAIN_DATA_STRUCTURES.graph-bfs",
        "peekOfCode": "class Node(object):\n    def __init__(self, name):\n        self.name = name\n        self.adjacencyList = []\n        self.visited = False\n        self.predecessor = None\nclass BreadthFirstSearch(object):\n    def bfs(self, startNode):\n        queue = []\n        queue.append(startNode)",
        "detail": "MAIN_DATA_STRUCTURES.graph-bfs",
        "documentation": {}
    },
    {
        "label": "BreadthFirstSearch",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.graph-bfs",
        "description": "MAIN_DATA_STRUCTURES.graph-bfs",
        "peekOfCode": "class BreadthFirstSearch(object):\n    def bfs(self, startNode):\n        queue = []\n        queue.append(startNode)\n        startNode.visited = True\n        # BFS -> queue      DFS --> stack BUT usually we implement it with recursion !!!\n        while queue:\n            actualNode = queue.pop(0)\n            print(\"%s \" % actualNode.name)\n            for n in actualNode.adjacencyList:",
        "detail": "MAIN_DATA_STRUCTURES.graph-bfs",
        "documentation": {}
    },
    {
        "label": "node1",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-bfs",
        "description": "MAIN_DATA_STRUCTURES.graph-bfs",
        "peekOfCode": "node1 = Node(\"A\")\nnode2 = Node(\"B\")\nnode3 = Node(\"C\")\nnode4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode1.adjacencyList.append(node2)\nnode1.adjacencyList.append(node3)\nnode2.adjacencyList.append(node4)\nnode4.adjacencyList.append(node5)\nbfs = BreadthFirstSearch()",
        "detail": "MAIN_DATA_STRUCTURES.graph-bfs",
        "documentation": {}
    },
    {
        "label": "node2",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-bfs",
        "description": "MAIN_DATA_STRUCTURES.graph-bfs",
        "peekOfCode": "node2 = Node(\"B\")\nnode3 = Node(\"C\")\nnode4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode1.adjacencyList.append(node2)\nnode1.adjacencyList.append(node3)\nnode2.adjacencyList.append(node4)\nnode4.adjacencyList.append(node5)\nbfs = BreadthFirstSearch()\nbfs.bfs(node1)",
        "detail": "MAIN_DATA_STRUCTURES.graph-bfs",
        "documentation": {}
    },
    {
        "label": "node3",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-bfs",
        "description": "MAIN_DATA_STRUCTURES.graph-bfs",
        "peekOfCode": "node3 = Node(\"C\")\nnode4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode1.adjacencyList.append(node2)\nnode1.adjacencyList.append(node3)\nnode2.adjacencyList.append(node4)\nnode4.adjacencyList.append(node5)\nbfs = BreadthFirstSearch()\nbfs.bfs(node1)",
        "detail": "MAIN_DATA_STRUCTURES.graph-bfs",
        "documentation": {}
    },
    {
        "label": "node4",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-bfs",
        "description": "MAIN_DATA_STRUCTURES.graph-bfs",
        "peekOfCode": "node4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode1.adjacencyList.append(node2)\nnode1.adjacencyList.append(node3)\nnode2.adjacencyList.append(node4)\nnode4.adjacencyList.append(node5)\nbfs = BreadthFirstSearch()\nbfs.bfs(node1)",
        "detail": "MAIN_DATA_STRUCTURES.graph-bfs",
        "documentation": {}
    },
    {
        "label": "node5",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-bfs",
        "description": "MAIN_DATA_STRUCTURES.graph-bfs",
        "peekOfCode": "node5 = Node(\"E\")\nnode1.adjacencyList.append(node2)\nnode1.adjacencyList.append(node3)\nnode2.adjacencyList.append(node4)\nnode4.adjacencyList.append(node5)\nbfs = BreadthFirstSearch()\nbfs.bfs(node1)",
        "detail": "MAIN_DATA_STRUCTURES.graph-bfs",
        "documentation": {}
    },
    {
        "label": "bfs",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-bfs",
        "description": "MAIN_DATA_STRUCTURES.graph-bfs",
        "peekOfCode": "bfs = BreadthFirstSearch()\nbfs.bfs(node1)",
        "detail": "MAIN_DATA_STRUCTURES.graph-bfs",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.graph-dfs",
        "description": "MAIN_DATA_STRUCTURES.graph-dfs",
        "peekOfCode": "class Node(object):\n    def __init__(self, name):\n        self.name = name\n        self.adjacencyList = []\n        self.visited = False\n        self.predecessor = None\nclass DepthFirstSearch(\n    object\n):  # BFS -> queue + layer by layer algorithm   DFS -> stack + goes\n    # as deep as possible into the tree !!!",
        "detail": "MAIN_DATA_STRUCTURES.graph-dfs",
        "documentation": {}
    },
    {
        "label": "DepthFirstSearch",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.graph-dfs",
        "description": "MAIN_DATA_STRUCTURES.graph-dfs",
        "peekOfCode": "class DepthFirstSearch(\n    object\n):  # BFS -> queue + layer by layer algorithm   DFS -> stack + goes\n    # as deep as possible into the tree !!!\n    def dfs(self, node):\n        node.visited = True\n        print(\"%s \" % node.name)\n        for n in node.adjacencyList:\n            if not n.visited:\n                self.dfs(n)",
        "detail": "MAIN_DATA_STRUCTURES.graph-dfs",
        "documentation": {}
    },
    {
        "label": "node1",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-dfs",
        "description": "MAIN_DATA_STRUCTURES.graph-dfs",
        "peekOfCode": "node1 = Node(\"A\")\nnode2 = Node(\"B\")\nnode3 = Node(\"C\")\nnode4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode1.adjacencyList.append(node2)\nnode1.adjacencyList.append(node3)\nnode2.adjacencyList.append(node4)\nnode4.adjacencyList.append(node5)\ndfs = DepthFirstSearch()",
        "detail": "MAIN_DATA_STRUCTURES.graph-dfs",
        "documentation": {}
    },
    {
        "label": "node2",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-dfs",
        "description": "MAIN_DATA_STRUCTURES.graph-dfs",
        "peekOfCode": "node2 = Node(\"B\")\nnode3 = Node(\"C\")\nnode4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode1.adjacencyList.append(node2)\nnode1.adjacencyList.append(node3)\nnode2.adjacencyList.append(node4)\nnode4.adjacencyList.append(node5)\ndfs = DepthFirstSearch()\ndfs.dfs(node1)",
        "detail": "MAIN_DATA_STRUCTURES.graph-dfs",
        "documentation": {}
    },
    {
        "label": "node3",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-dfs",
        "description": "MAIN_DATA_STRUCTURES.graph-dfs",
        "peekOfCode": "node3 = Node(\"C\")\nnode4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode1.adjacencyList.append(node2)\nnode1.adjacencyList.append(node3)\nnode2.adjacencyList.append(node4)\nnode4.adjacencyList.append(node5)\ndfs = DepthFirstSearch()\ndfs.dfs(node1)",
        "detail": "MAIN_DATA_STRUCTURES.graph-dfs",
        "documentation": {}
    },
    {
        "label": "node4",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-dfs",
        "description": "MAIN_DATA_STRUCTURES.graph-dfs",
        "peekOfCode": "node4 = Node(\"D\")\nnode5 = Node(\"E\")\nnode1.adjacencyList.append(node2)\nnode1.adjacencyList.append(node3)\nnode2.adjacencyList.append(node4)\nnode4.adjacencyList.append(node5)\ndfs = DepthFirstSearch()\ndfs.dfs(node1)",
        "detail": "MAIN_DATA_STRUCTURES.graph-dfs",
        "documentation": {}
    },
    {
        "label": "node5",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-dfs",
        "description": "MAIN_DATA_STRUCTURES.graph-dfs",
        "peekOfCode": "node5 = Node(\"E\")\nnode1.adjacencyList.append(node2)\nnode1.adjacencyList.append(node3)\nnode2.adjacencyList.append(node4)\nnode4.adjacencyList.append(node5)\ndfs = DepthFirstSearch()\ndfs.dfs(node1)",
        "detail": "MAIN_DATA_STRUCTURES.graph-dfs",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.graph-dfs",
        "description": "MAIN_DATA_STRUCTURES.graph-dfs",
        "peekOfCode": "dfs = DepthFirstSearch()\ndfs.dfs(node1)",
        "detail": "MAIN_DATA_STRUCTURES.graph-dfs",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.hashtable",
        "description": "MAIN_DATA_STRUCTURES.hashtable",
        "peekOfCode": "class HashTable(object):\n    def __init__(self):\n        self.size = 10\n        self.keys = [None] * self.size\n        self.values = [None] * self.size\n    def put(self, key, data):\n        index = self.hashfunction(key)\n        # not None -> it is a collision !!!\n        while self.keys[index] is not None:\n            if self.keys[index] == key:",
        "detail": "MAIN_DATA_STRUCTURES.hashtable",
        "documentation": {}
    },
    {
        "label": "table",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.hashtable",
        "description": "MAIN_DATA_STRUCTURES.hashtable",
        "peekOfCode": "table = HashTable()\ntable.put(\"apple\", 10)\ntable.put(\"orange\", 20)\ntable.put(\"car\", 30)\ntable.put(\"table\", 40)\nprint(table.get(\"car\"))",
        "detail": "MAIN_DATA_STRUCTURES.hashtable",
        "documentation": {}
    },
    {
        "label": "Heap",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.heaps",
        "description": "MAIN_DATA_STRUCTURES.heaps",
        "peekOfCode": "class Heap(object):\n    def __init__(self):\n        # create array with as many slots as the CAPACITY\n        self.heap = [0] * CAPACITY\n        # track the size of the heap (the number of items in the heap)\n        self.heap_size = 0\n    # insertion takes O(1) running time BUT we have to make sure that hte\n    # heap properties are not violated (it takes O(logN) because of the\n    # fixUp() method)\n    def insert(self, item):",
        "detail": "MAIN_DATA_STRUCTURES.heaps",
        "documentation": {}
    },
    {
        "label": "CAPACITY",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.heaps",
        "description": "MAIN_DATA_STRUCTURES.heaps",
        "peekOfCode": "CAPACITY = 10\n\"\"\"\n*** Max Heap ***\n----------------\n\"\"\"\n# define the heap class\nclass Heap(object):\n    def __init__(self):\n        # create array with as many slots as the CAPACITY\n        self.heap = [0] * CAPACITY",
        "detail": "MAIN_DATA_STRUCTURES.heaps",
        "documentation": {}
    },
    {
        "label": "heap",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.heaps",
        "description": "MAIN_DATA_STRUCTURES.heaps",
        "peekOfCode": "heap = Heap()\nheap.insert(10)\nheap.insert(8)\nheap.insert(12)\nheap.insert(20)\nheap.insert(-2)\nheap.insert(0)\nheap.insert(1)\nheap.insert(321)\nheap.heap_sort()",
        "detail": "MAIN_DATA_STRUCTURES.heaps",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.linked-lists",
        "description": "MAIN_DATA_STRUCTURES.linked-lists",
        "peekOfCode": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.nextNode = None\n\"\"\"\nNext the linked list can be created and initialized with the head as none \nbecause it doesn't exist yet and the number of nodes to 0 because its empty\n\"\"\"\nclass LinkedList:\n    def __init__(self):",
        "detail": "MAIN_DATA_STRUCTURES.linked-lists",
        "documentation": {}
    },
    {
        "label": "LinkedList",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.linked-lists",
        "description": "MAIN_DATA_STRUCTURES.linked-lists",
        "peekOfCode": "class LinkedList:\n    def __init__(self):\n        self.head = None\n        self.numOfNodes = 0\n        \"\"\"\n        Functions for the LinkedList class:\n        \"\"\"\n    # function to insert a new node at the beginning of the list O(1)\n    def insert_start(self, data):\n        # first increase the number of nodes by 1",
        "detail": "MAIN_DATA_STRUCTURES.linked-lists",
        "documentation": {}
    },
    {
        "label": "linked_list",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.linked-lists",
        "description": "MAIN_DATA_STRUCTURES.linked-lists",
        "peekOfCode": "linked_list = LinkedList()\n# insert a few nodes at the beginning of the list O(1)\nlinked_list.insert_start(4)\nlinked_list.insert_start(3)\nlinked_list.insert_start(7)\n# insert a node at the end of the list O(N)\nlinked_list.insert_end(10)\n# remove a node from list O(N)\nlinked_list.remove(3)\n# print the node values of the list O(N)",
        "detail": "MAIN_DATA_STRUCTURES.linked-lists",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.queue",
        "description": "MAIN_DATA_STRUCTURES.queue",
        "peekOfCode": "class Queue:\n    def __init__(self):\n        # initialize it to a one dimensional array or linked list\n        self.queue = []\n    \"\"\"\n    Stack methods (enqueue, dequeue, peek, is_empty, size_queue)\n    \"\"\"\n    # function to check if the queue is empty O(1)\n    def is_empty(self):\n        return self.queue == []",
        "detail": "MAIN_DATA_STRUCTURES.queue",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.queue",
        "description": "MAIN_DATA_STRUCTURES.queue",
        "peekOfCode": "queue = Queue()\nqueue.enqueue(1)\nqueue.enqueue(2)\nqueue.enqueue(3)\nprint(f\"Size: {queue.size_queue()}\")\nprint(f\"Dequeue: {queue.dequeue()}\")\nprint(f\"Size: {queue.size_queue()}\")\nprint(f\"Peeked item: {queue.peek()}\")\nprint(f\"Size: {queue.size_queue()}\")",
        "detail": "MAIN_DATA_STRUCTURES.queue",
        "documentation": {}
    },
    {
        "label": "Color",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.red_black_tree",
        "description": "MAIN_DATA_STRUCTURES.red_black_tree",
        "peekOfCode": "class Color:\n    RED = 1\n    BLACK = 2\nclass Node:\n    def __init__(self, data, parent=None, color=Color.RED):\n        self.data = data\n        self.color = color\n        self.parent = parent\n        self.left = None\n        self.right = None",
        "detail": "MAIN_DATA_STRUCTURES.red_black_tree",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.red_black_tree",
        "description": "MAIN_DATA_STRUCTURES.red_black_tree",
        "peekOfCode": "class Node:\n    def __init__(self, data, parent=None, color=Color.RED):\n        self.data = data\n        self.color = color\n        self.parent = parent\n        self.left = None\n        self.right = None\nclass RedBlackTree:\n    def __init__(self):\n        self.root = None",
        "detail": "MAIN_DATA_STRUCTURES.red_black_tree",
        "documentation": {}
    },
    {
        "label": "RedBlackTree",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.red_black_tree",
        "description": "MAIN_DATA_STRUCTURES.red_black_tree",
        "peekOfCode": "class RedBlackTree:\n    def __init__(self):\n        self.root = None\n    def insert(self, data):\n        if not self.root:\n            self.root = Node(data)\n            self.violate(self.root)\n        else:\n            self.insert_node(data, self.root)\n    def insert_node(self, data, node):",
        "detail": "MAIN_DATA_STRUCTURES.red_black_tree",
        "documentation": {}
    },
    {
        "label": "rbt",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.red_black_tree",
        "description": "MAIN_DATA_STRUCTURES.red_black_tree",
        "peekOfCode": "rbt = RedBlackTree()\nrbt.insert(32)\nrbt.insert(10)\nrbt.insert(55)\nrbt.insert(1)\nrbt.insert(19)\nrbt.insert(79)\nrbt.insert(16)\nrbt.insert(23)\nrbt.insert(12)",
        "detail": "MAIN_DATA_STRUCTURES.red_black_tree",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.stack",
        "description": "MAIN_DATA_STRUCTURES.stack",
        "peekOfCode": "class Stack:\n    def __init__(self):\n        # initialize it to a one dimensional array or linked list\n        self.stack = []\n    \"\"\"\n    Stack methods (push, pop, peek, is_empty, stack_size)\n    \"\"\"\n    # function for adding item into the stack O(1)\n    def push(self, data):\n        self.stack.append(data)",
        "detail": "MAIN_DATA_STRUCTURES.stack",
        "documentation": {}
    },
    {
        "label": "stack",
        "kind": 5,
        "importPath": "MAIN_DATA_STRUCTURES.stack",
        "description": "MAIN_DATA_STRUCTURES.stack",
        "peekOfCode": "stack = Stack()\nstack.push(1)\nstack.push(2)\nstack.push(3)\nprint(f\"Size: {stack.stack_size()}\")\nprint(f\"Popped item: {stack.pop()}\")\nprint(f\"Size: {stack.stack_size()}\")\nprint(f\"Peeked item: {stack.peek()}\")\nprint(f\"Size: {stack.stack_size()}\")",
        "detail": "MAIN_DATA_STRUCTURES.stack",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.ternary-search-trees",
        "description": "MAIN_DATA_STRUCTURES.ternary-search-trees",
        "peekOfCode": "class Node(object):\n    def __init__(self, character):\n        self.character = character\n        self.leftNode = None\n        self.middleNode = None\n        self.rightNode = None\n        self.value = 0\nclass TST(object):\n    def __init__(self):\n        self.rootNode = None",
        "detail": "MAIN_DATA_STRUCTURES.ternary-search-trees",
        "documentation": {}
    },
    {
        "label": "TST",
        "kind": 6,
        "importPath": "MAIN_DATA_STRUCTURES.ternary-search-trees",
        "description": "MAIN_DATA_STRUCTURES.ternary-search-trees",
        "peekOfCode": "class TST(object):\n    def __init__(self):\n        self.rootNode = None\n    def put(self, key, value):\n        self.rootNode = self.putItem(self.rootNode, key, value, 0)\n    def putItem(self, node, key, value, index):\n        c = key[index]\n        if node is None:\n            node = Node(c)\n        if c < node.character:",
        "detail": "MAIN_DATA_STRUCTURES.ternary-search-trees",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "kind": 2,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Search.binary_search",
        "description": "practice.Algorithms-Data-Structures-master.Binary Search.binary_search",
        "peekOfCode": "def binary_search(input_array, value):\n    test_array = input_array\n    current_index = len(input_array) // 2\n    input_index = current_index\n    found_value = test_array[current_index]\n    while len(test_array) > 1 and found_value != value:\n        if found_value < value:\n            test_array = test_array[current_index:]\n            current_index = len(test_array) // 2\n            input_index += current_index",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Search.binary_search",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "kind": 2,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Search.binary_search",
        "description": "practice.Algorithms-Data-Structures-master.Binary Search.binary_search",
        "peekOfCode": "def linear_search(a, x):\n    for i in range(len(a)):\n        if a[i] == x:\n            return i\n    return -1\n# compare naive algorithm linear search vs. binary search results\ndef stress_test(n, m):\n    test_cond = True\n    while test_cond:\n        a = []",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Search.binary_search",
        "documentation": {}
    },
    {
        "label": "stress_test",
        "kind": 2,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Search.binary_search",
        "description": "practice.Algorithms-Data-Structures-master.Binary Search.binary_search",
        "peekOfCode": "def stress_test(n, m):\n    test_cond = True\n    while test_cond:\n        a = []\n        for i in range(n):\n            a.append(random.randint(0, 10 ** 9))\n        a.sort()\n        for i in range(m):\n            b = random.randint(0, n - 1)\n            print([linear_search(a, a[b]), binary_search(a, a[b])])",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Search.binary_search",
        "documentation": {}
    },
    {
        "label": "binary_search_recursive",
        "kind": 2,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Search.recursive_binary_search",
        "description": "practice.Algorithms-Data-Structures-master.Binary Search.recursive_binary_search",
        "peekOfCode": "def binary_search_recursive(a, x, left=0, right=(len(a)-1)):\n\"\"\"Recursive Binary Search algorithm implemented using list indexing\"\"\"\n    index = (left+right)//2\n    if a[index]==x:\n        return index\n    elif x>(a[right]) or x<a[left]: # first case where x is not in the list!\n        return -1\n    elif left==right: # case where search is complete and no value x not found\n        return -1\n    elif left==right-1: # case where there are only two numbers left, check both!",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Search.recursive_binary_search",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Trees.binary_search_tree",
        "description": "practice.Algorithms-Data-Structures-master.Binary Trees.binary_search_tree",
        "peekOfCode": "class Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\nclass BST(object):\n    def __init__(self, root):\n        self.root = Node(root)\n    def insert(self, new_val):\n        if(self.root.left==None):",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Trees.binary_search_tree",
        "documentation": {}
    },
    {
        "label": "BST",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Trees.binary_search_tree",
        "description": "practice.Algorithms-Data-Structures-master.Binary Trees.binary_search_tree",
        "peekOfCode": "class BST(object):\n    def __init__(self, root):\n        self.root = Node(root)\n    def insert(self, new_val):\n        if(self.root.left==None):\n            if(self.root.value>new_val):\n                self.root.left = Node(new_val)\n        elif(self.root.right==None):\n            if(self.root.value<new_val):\n                self.root.right = Node(new_val)",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Trees.binary_search_tree",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Trees.binary_search_tree",
        "description": "practice.Algorithms-Data-Structures-master.Binary Trees.binary_search_tree",
        "peekOfCode": "tree = BST(4)\n# Insert elements\ntree.insert(2)\ntree.insert(1)\ntree.insert(3)\ntree.insert(5)\n# Check search\n# Should be True\nprint tree.search(4)\n# Should be False",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Trees.binary_search_tree",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "description": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "peekOfCode": "class Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\nclass BinaryTree(object):\n    def __init__(self, root):\n        self.root = Node(root)\n    def preorder_search(self, start, find_val):\n        \"\"\"Helper method - use this to create a",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "BinaryTree",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "description": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "peekOfCode": "class BinaryTree(object):\n    def __init__(self, root):\n        self.root = Node(root)\n    def preorder_search(self, start, find_val):\n        \"\"\"Helper method - use this to create a\n        recursive search solution.\"\"\"\n        if start.value == find_val:\n            return True\n        if start.left != None:\n            left_result = self.preorder_search(start.left, find_val)",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "tree",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "description": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "peekOfCode": "tree = BinaryTree(1)\ntree.root.left = Node(2)\ntree.root.right = Node(3)\ntree.root.left.left = Node(4)\ntree.root.left.right = Node(5)\n# Test search\n# Should be True\nprint(tree.search(4))\n# Should be False\nprint(tree.search(6))",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "tree.root.left",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "description": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "peekOfCode": "tree.root.left = Node(2)\ntree.root.right = Node(3)\ntree.root.left.left = Node(4)\ntree.root.left.right = Node(5)\n# Test search\n# Should be True\nprint(tree.search(4))\n# Should be False\nprint(tree.search(6))\n# Test print_tree",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "tree.root.right",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "description": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "peekOfCode": "tree.root.right = Node(3)\ntree.root.left.left = Node(4)\ntree.root.left.right = Node(5)\n# Test search\n# Should be True\nprint(tree.search(4))\n# Should be False\nprint(tree.search(6))\n# Test print_tree\n# Should be 1-2-4-5-3",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "tree.root.left.left",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "description": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "peekOfCode": "tree.root.left.left = Node(4)\ntree.root.left.right = Node(5)\n# Test search\n# Should be True\nprint(tree.search(4))\n# Should be False\nprint(tree.search(6))\n# Test print_tree\n# Should be 1-2-4-5-3\nprint(tree.print_tree())",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "tree.root.left.right",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "description": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "peekOfCode": "tree.root.left.right = Node(5)\n# Test search\n# Should be True\nprint(tree.search(4))\n# Should be False\nprint(tree.search(6))\n# Test print_tree\n# Should be 1-2-4-5-3\nprint(tree.print_tree())",
        "detail": "practice.Algorithms-Data-Structures-master.Binary Trees.preorder_operations",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "description": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "peekOfCode": "class Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.edges = []\nclass Edge(object):\n    def __init__(self, value, node_from, node_to):\n        self.value = value\n        self.node_from = node_from\n        self.node_to = node_to\nclass Graph(object):",
        "detail": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "documentation": {}
    },
    {
        "label": "Edge",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "description": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "peekOfCode": "class Edge(object):\n    def __init__(self, value, node_from, node_to):\n        self.value = value\n        self.node_from = node_from\n        self.node_to = node_to\nclass Graph(object):\n    def __init__(self, nodes=[], edges=[]):\n        self.nodes = nodes\n        self.edges = edges\n    def insert_node(self, new_node_val):",
        "detail": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "description": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "peekOfCode": "class Graph(object):\n    def __init__(self, nodes=[], edges=[]):\n        self.nodes = nodes\n        self.edges = edges\n    def insert_node(self, new_node_val):\n        new_node = Node(new_node_val)\n        self.nodes.append(new_node)\n    def insert_edge(self, new_edge_val, node_from_val, node_to_val):\n        from_found = None\n        to_found = None",
        "detail": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "description": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "peekOfCode": "graph = Graph()\ngraph.insert_edge(100, 1, 2)\ngraph.insert_edge(101, 1, 3)\ngraph.insert_edge(102, 1, 4)\ngraph.insert_edge(103, 3, 4)\n# Should be [(100, 1, 2), (101, 1, 3), (102, 1, 4), (103, 3, 4)]\nprint(graph.get_edge_list())\n# Should be [None, [(2, 100), (3, 101), (4, 102)], None, [(4, 103)], None]\nprint(graph.get_adjacency_list())\n# Should be [[0, 0, 0, 0, 0], [0, 0, 100, 101, 102], [0, 0, 0, 0, 0], [0, 0, 0, 0, 103], [0, 0, 0, 0, 0]]",
        "detail": "practice.Algorithms-Data-Structures-master.Graphs.directed_graph",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "description": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "peekOfCode": "class Node(object):\n    def __init__(self, value):\n        self.value = value\n        self.edges = []\n        self.visited = False\nclass Edge(object):\n    def __init__(self, value, node_from, node_to):\n        self.value = value\n        self.node_from = node_from\n        self.node_to = node_to",
        "detail": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "documentation": {}
    },
    {
        "label": "Edge",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "description": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "peekOfCode": "class Edge(object):\n    def __init__(self, value, node_from, node_to):\n        self.value = value\n        self.node_from = node_from\n        self.node_to = node_to\n# You only need to change code with docs strings that have TODO.\n# Specifically: Graph.dfs_helper and Graph.bfs\n# New methods have been added to associate node numbers with names\n# Specifically: Graph.set_node_names\n# and the methods ending in \"_names\" which will print names instead",
        "detail": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "documentation": {}
    },
    {
        "label": "Graph",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "description": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "peekOfCode": "class Graph(object):\n    def __init__(self, nodes=None, edges=None):\n        self.nodes = nodes or []\n        self.edges = edges or []\n        self.node_names = []\n        self._node_map = {}\n    def set_node_names(self, names):\n        \"\"\"The Nth name in names should correspond to node number N.\n        Node numbers are 0 based (starting at 0).\n        \"\"\"",
        "detail": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "documentation": {}
    },
    {
        "label": "graph",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "description": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "peekOfCode": "graph = Graph()\n# You do not need to change anything below this line.\n# You only need to implement Graph.dfs_helper and Graph.bfs\ngraph.set_node_names(\n    (\n        \"Mountain View\",  # 0\n        \"San Francisco\",  # 1\n        \"London\",  # 2\n        \"Shanghai\",  # 3\n        \"Berlin\",  # 4",
        "detail": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "documentation": {}
    },
    {
        "label": "pp",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "description": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "peekOfCode": "pp = pprint.PrettyPrinter(indent=2)\nprint(\"Edge List\")\npp.pprint(graph.get_edge_list_names())\nprint(\"\\nAdjacency List\")\npp.pprint(graph.get_adjacency_list_names())\nprint(\"\\nAdjacency Matrix\")\npp.pprint(graph.get_adjacency_matrix())\nprint(\"\\nDepth First Search\")\npp.pprint(graph.dfs_names(2))\n# Should print:",
        "detail": "practice.Algorithms-Data-Structures-master.Graphs.graph_traversal",
        "documentation": {}
    },
    {
        "label": "HashTable",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Hash Tables.HashTable",
        "description": "practice.Algorithms-Data-Structures-master.Hash Tables.HashTable",
        "peekOfCode": "class HashTable(object):\n    def __init__(self):\n        self.table = [None]*10000\n    def store(self, string):\n        \"\"\"Input a string that's stored in\n        the table.\"\"\"\n        index = self.calculate_hash_value(string)\n        if(self.lookup(string)==-1):\n            self.table[index] = [string]\n        else:",
        "detail": "practice.Algorithms-Data-Structures-master.Hash Tables.HashTable",
        "documentation": {}
    },
    {
        "label": "hash_table",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Hash Tables.HashTable",
        "description": "practice.Algorithms-Data-Structures-master.Hash Tables.HashTable",
        "peekOfCode": "hash_table = HashTable()\n# Test calculate_hash_value\n# Should be 8568\nprint hash_table.calculate_hash_value('UDACITY')\n# Test lookup edge case\n# Should be -1\nprint hash_table.lookup('UDACITY')\n# Test store\nhash_table.store('UDACITY')\n# Should be 8568",
        "detail": "practice.Algorithms-Data-Structures-master.Hash Tables.HashTable",
        "documentation": {}
    },
    {
        "label": "Element",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "description": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "peekOfCode": "class Element(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None\nclass LinkedList(object):\n    def __init__(self, head=None):\n        self.head = head\n    def append(self, new_element):\n        current = self.head\n        if self.head:",
        "detail": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "LinkedList",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "description": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "peekOfCode": "class LinkedList(object):\n    def __init__(self, head=None):\n        self.head = head\n    def append(self, new_element):\n        current = self.head\n        if self.head:\n            while current.next:\n                current = current.next\n            current.next = new_element\n        else:",
        "detail": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "e1",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "description": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "peekOfCode": "e1 = Element(1)\ne2 = Element(2)\ne3 = Element(3)\ne4 = Element(4)\n# Start setting up a LinkedList\nll = LinkedList(e1)\nll.append(e2)\nll.append(e3)\n# Test get_position\n# Should print 3",
        "detail": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "e2",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "description": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "peekOfCode": "e2 = Element(2)\ne3 = Element(3)\ne4 = Element(4)\n# Start setting up a LinkedList\nll = LinkedList(e1)\nll.append(e2)\nll.append(e3)\n# Test get_position\n# Should print 3\nprint ll.head.next.next.value",
        "detail": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "e3",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "description": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "peekOfCode": "e3 = Element(3)\ne4 = Element(4)\n# Start setting up a LinkedList\nll = LinkedList(e1)\nll.append(e2)\nll.append(e3)\n# Test get_position\n# Should print 3\nprint ll.head.next.next.value\n# Should also print 3",
        "detail": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "e4",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "description": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "peekOfCode": "e4 = Element(4)\n# Start setting up a LinkedList\nll = LinkedList(e1)\nll.append(e2)\nll.append(e3)\n# Test get_position\n# Should print 3\nprint ll.head.next.next.value\n# Should also print 3\nprint ll.get_position(3).value",
        "detail": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "ll",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "description": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "peekOfCode": "ll = LinkedList(e1)\nll.append(e2)\nll.append(e3)\n# Test get_position\n# Should print 3\nprint ll.head.next.next.value\n# Should also print 3\nprint ll.get_position(3).value\n# Test insert\nll.insert(e4,3)",
        "detail": "practice.Algorithms-Data-Structures-master.Linked Lists.Linked_Lists",
        "documentation": {}
    },
    {
        "label": "Queue",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Queues.Queues_Class_Practice",
        "description": "practice.Algorithms-Data-Structures-master.Queues.Queues_Class_Practice",
        "peekOfCode": "class Queue:\n    def __init__(self, head=None):\n        self.storage = [head]\n    def enqueue(self, new_element):\n        if(self.storage):\n            self.storage.append(new_element)\n        else:\n            self.storage = [new_element]\n        return new_element\n    def peek(self):",
        "detail": "practice.Algorithms-Data-Structures-master.Queues.Queues_Class_Practice",
        "documentation": {}
    },
    {
        "label": "q",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Queues.Queues_Class_Practice",
        "description": "practice.Algorithms-Data-Structures-master.Queues.Queues_Class_Practice",
        "peekOfCode": "q = Queue(1)\nq.enqueue(2)\nq.enqueue(3)\n# Test peek\n# Should be 1\nprint q.peek()\n# Test dequeue\n# Should be 1\nprint q.dequeue()\n# Test enqueue",
        "detail": "practice.Algorithms-Data-Structures-master.Queues.Queues_Class_Practice",
        "documentation": {}
    },
    {
        "label": "get_fib",
        "kind": 2,
        "importPath": "practice.Algorithms-Data-Structures-master.Recursion.fibonacci",
        "description": "practice.Algorithms-Data-Structures-master.Recursion.fibonacci",
        "peekOfCode": "def get_fib(position):\n    output = 0\n    if(position==0):\n        return output\n    if(position==1):\n        return position\n    else:\n        output += get_fib(position-1)+get_fib(position-2)\n        return output\n# Test cases",
        "detail": "practice.Algorithms-Data-Structures-master.Recursion.fibonacci",
        "documentation": {}
    },
    {
        "label": "mergeSort",
        "kind": 2,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.mergesort_from_book",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.mergesort_from_book",
        "peekOfCode": "def mergeSort(list):\n    # Determine whether the list is broken into\n    # individual pieces.\n    if len(list) < 2:\n        return list\n    # Find the middle of the list.\n    middle = len(list) // 2\n    # Break the list into two pieces.\n    left = mergeSort(list[:middle])\n    right = mergeSort(list[middle:])",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.mergesort_from_book",
        "documentation": {}
    },
    {
        "label": "merge",
        "kind": 2,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.mergesort_from_book",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.mergesort_from_book",
        "peekOfCode": "def merge(left, right):\n    # When the left side or the right side is empty,\n    # it means that this is an individual item and is\n    # already sorted.\n    if not len(left):\n        return left\n    if not len(right):\n        return right\n    # Define variables used to merge the two pieces.\n    result = []",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.mergesort_from_book",
        "documentation": {}
    },
    {
        "label": "quicksort",
        "kind": 2,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "peekOfCode": "def quicksort(array):\n    if len(array) <= 1:\n        return array\n    else:\n        pivot = array[-1]\n        n = 0\n        i = 0\n        while n < len(array) - i:\n            # print(array)\n            # print(n)",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "peekOfCode": "test = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]\ntimes = []\nfor i in range(1000):\n    start = time.clock()\n    quicksort(test)\n    end = time.clock()\n    times.append(end - start)\naverage = sum(times) / len(times)\nprint(average)",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "documentation": {}
    },
    {
        "label": "times",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "peekOfCode": "times = []\nfor i in range(1000):\n    start = time.clock()\n    quicksort(test)\n    end = time.clock()\n    times.append(end - start)\naverage = sum(times) / len(times)\nprint(average)",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "documentation": {}
    },
    {
        "label": "average",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "peekOfCode": "average = sum(times) / len(times)\nprint(average)",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.quicksort",
        "documentation": {}
    },
    {
        "label": "quicksort_equal_elements",
        "kind": 2,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_for_equal_elems",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_for_equal_elems",
        "peekOfCode": "def quicksort_equal_elements(s):\n    \"\"\"Quicksort from finxter modified to add all elements equal to the pivot\n    directly after the pivot, so that quicksort performs faster for cases\n    where there are many identical elements in the array to be sorted (e.g.\n    there are only 2 values for all elements, or 1 unique value in a large\n    array, etc.)\"\"\"\n    if len(s) < 2:\n        return s\n    else:\n        # upgraded to work for sets with multiple identical numbers!",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_for_equal_elems",
        "documentation": {}
    },
    {
        "label": "A",
        "kind": 2,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "peekOfCode": "def A(s):\n    if len(s) < 2:\n        return s\n    else:\n        return (\n            A([x for x in s[1:] if x < s[0]])\n            + [s[0]]\n            + A([x for x in s[1:] if x >= s[0]])\n        )\n# start = time.clock()",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "peekOfCode": "test = [21, 4, 1, 3, 9, 20, 25, 6, 21, 14]\ntimes = []\nfor i in range(1000):\n    start = time.clock()\n    A(test)\n    end = time.clock()\n    times.append(end - start)\naverage = sum(times) / len(times)\nprint(average)",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "documentation": {}
    },
    {
        "label": "times",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "peekOfCode": "times = []\nfor i in range(1000):\n    start = time.clock()\n    A(test)\n    end = time.clock()\n    times.append(end - start)\naverage = sum(times) / len(times)\nprint(average)",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "documentation": {}
    },
    {
        "label": "average",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "description": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "peekOfCode": "average = sum(times) / len(times)\nprint(average)",
        "detail": "practice.Algorithms-Data-Structures-master.Sorting.quicksort_from_finxter",
        "documentation": {}
    },
    {
        "label": "Element",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "description": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "peekOfCode": "class Element(object):\n    def __init__(self, value):\n        self.value = value\n        self.next = None\nclass LinkedList(object):\n    def __init__(self, head=None):\n        self.head = head\n    def append(self, new_element):\n        current = self.head\n        if self.head:",
        "detail": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "LinkedList",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "description": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "peekOfCode": "class LinkedList(object):\n    def __init__(self, head=None):\n        self.head = head\n    def append(self, new_element):\n        current = self.head\n        if self.head:\n            while current.next:\n                current = current.next\n            current.next = new_element\n        else:",
        "detail": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "Stack",
        "kind": 6,
        "importPath": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "description": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "peekOfCode": "class Stack(object):\n    def __init__(self,top=None):\n        self.ll = LinkedList(top)\n    def push(self, new_element):\n        \"Push (add) a new element onto the top of the stack\"\n        former = self.ll.head\n        new_element.next = former\n        self.ll.head = new_element\n        pass\n    def pop(self):",
        "detail": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "e1",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "description": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "peekOfCode": "e1 = Element(1)\ne2 = Element(2)\ne3 = Element(3)\ne4 = Element(4)\n# Start setting up a Stack\nstack = Stack(e1)\n# Test stack functionality\nstack.push(e2)\nstack.push(e3)\nprint stack.pop().value",
        "detail": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "e2",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "description": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "peekOfCode": "e2 = Element(2)\ne3 = Element(3)\ne4 = Element(4)\n# Start setting up a Stack\nstack = Stack(e1)\n# Test stack functionality\nstack.push(e2)\nstack.push(e3)\nprint stack.pop().value\nprint stack.pop().value",
        "detail": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "e3",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "description": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "peekOfCode": "e3 = Element(3)\ne4 = Element(4)\n# Start setting up a Stack\nstack = Stack(e1)\n# Test stack functionality\nstack.push(e2)\nstack.push(e3)\nprint stack.pop().value\nprint stack.pop().value\nprint stack.pop().value",
        "detail": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "e4",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "description": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "peekOfCode": "e4 = Element(4)\n# Start setting up a Stack\nstack = Stack(e1)\n# Test stack functionality\nstack.push(e2)\nstack.push(e3)\nprint stack.pop().value\nprint stack.pop().value\nprint stack.pop().value\nprint stack.pop()",
        "detail": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "stack",
        "kind": 5,
        "importPath": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "description": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "peekOfCode": "stack = Stack(e1)\n# Test stack functionality\nstack.push(e2)\nstack.push(e3)\nprint stack.pop().value\nprint stack.pop().value\nprint stack.pop().value\nprint stack.pop()\nstack.push(e4)\nprint stack.pop().value",
        "detail": "practice.Algorithms-Data-Structures-master.Stacks.Stack_Quiz",
        "documentation": {}
    },
    {
        "label": "amendTheSentence",
        "kind": 2,
        "importPath": "practice.amendTheSentence.solution",
        "description": "practice.amendTheSentence.solution",
        "peekOfCode": "def amendTheSentence(s):\n    out_s = s[0].lower()\n    for char in s[1:]:\n        if char.islower():\n            out_s += char\n        else:\n            out_s += \" \" + char.lower()\n    return out_s\ns = \"AHMm\"\nprint(amendTheSentence(s))",
        "detail": "practice.amendTheSentence.solution",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "practice.amendTheSentence.solution",
        "description": "practice.amendTheSentence.solution",
        "peekOfCode": "s = \"AHMm\"\nprint(amendTheSentence(s))",
        "detail": "practice.amendTheSentence.solution",
        "documentation": {}
    },
    {
        "label": "areFollowingPatterns",
        "kind": 2,
        "importPath": "practice.areFollowingPattern.solution",
        "description": "practice.areFollowingPattern.solution",
        "peekOfCode": "def areFollowingPatterns(strings, patterns):\n    d = {}\n    for ele in range(len(strings)):\n        if d.get(strings[ele]):\n            if d[strings[ele]] != patterns[ele]:\n                return False\n        elif patterns[ele] in d.values():\n            return False\n        else:\n            d[strings[ele]] = patterns[ele]",
        "detail": "practice.areFollowingPattern.solution",
        "documentation": {}
    },
    {
        "label": "strings",
        "kind": 5,
        "importPath": "practice.areFollowingPattern.solution",
        "description": "practice.areFollowingPattern.solution",
        "peekOfCode": "strings = [\"cat\", \"dog\", \"doggy\"]\npatterns = [\"a\", \"b\", \"b\"]\nprint(areFollowingPatterns(strings, patterns))",
        "detail": "practice.areFollowingPattern.solution",
        "documentation": {}
    },
    {
        "label": "patterns",
        "kind": 5,
        "importPath": "practice.areFollowingPattern.solution",
        "description": "practice.areFollowingPattern.solution",
        "peekOfCode": "patterns = [\"a\", \"b\", \"b\"]\nprint(areFollowingPatterns(strings, patterns))",
        "detail": "practice.areFollowingPattern.solution",
        "documentation": {}
    },
    {
        "label": "beautifulText",
        "kind": 2,
        "importPath": "practice.BeautifulText.solution",
        "description": "practice.BeautifulText.solution",
        "peekOfCode": "def beautifulText(inputString, l, r):\n    for w in range(l, r + 1):\n        i = w\n        while i < len(inputString):\n            if inputString[i] != \" \":\n                break\n            i += w + 1\n        if i == len(inputString):\n            return True\n    return False",
        "detail": "practice.BeautifulText.solution",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "practice.BeautifulText.solution",
        "description": "practice.BeautifulText.solution",
        "peekOfCode": "s = \"Look at this example of a correct text\"\nprint(beautifulText(s, 5, 15))",
        "detail": "practice.BeautifulText.solution",
        "documentation": {}
    },
    {
        "label": "binarySearch",
        "kind": 2,
        "importPath": "practice.binarySearchRec.solution",
        "description": "practice.binarySearchRec.solution",
        "peekOfCode": "def binarySearch(arr, searchValue):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] < searchValue:\n            low = mid + 1\n        elif arr[mid] > searchValue:\n            high = mid - 1\n        else:",
        "detail": "practice.binarySearchRec.solution",
        "documentation": {}
    },
    {
        "label": "binarySearchRec",
        "kind": 2,
        "importPath": "practice.binarySearchRec.solution",
        "description": "practice.binarySearchRec.solution",
        "peekOfCode": "def binarySearchRec(arr, search_value):\n    if len(arr) == 0:\n        return False",
        "detail": "practice.binarySearchRec.solution",
        "documentation": {}
    },
    {
        "label": "boxBlur",
        "kind": 2,
        "importPath": "practice.boxBlur.solution",
        "description": "practice.boxBlur.solution",
        "peekOfCode": "def boxBlur(image):\n    out = []\n    for i in range(len(image) - 2):\n        out.append(\n            [\n                (\n                    sum(image[i][j : j + 3])\n                    + sum(image[i + 1][j : j + 3])\n                    + sum(image[i + 2][j : j + 3])\n                )",
        "detail": "practice.boxBlur.solution",
        "documentation": {}
    },
    {
        "label": "image",
        "kind": 5,
        "importPath": "practice.boxBlur.solution",
        "description": "practice.boxBlur.solution",
        "peekOfCode": "image = [[7, 4, 0, 1], [5, 6, 2, 2], [6, 10, 7, 8], [1, 4, 2, 0]]\nprint(boxBlur(image))",
        "detail": "practice.boxBlur.solution",
        "documentation": {}
    },
    {
        "label": "rec_bin",
        "kind": 2,
        "importPath": "practice.convertToBinary.solution",
        "description": "practice.convertToBinary.solution",
        "peekOfCode": "def rec_bin(n):\n    if n == 0:\n        return \"\"\n    else:\n        return str(n % 2) + rec_bin(n // 2)\nprint(rec_bin(20))\nprint(bin(20)[2:])",
        "detail": "practice.convertToBinary.solution",
        "documentation": {}
    },
    {
        "label": "drawRectangle",
        "kind": 2,
        "importPath": "practice.drawRectangle.solution",
        "description": "practice.drawRectangle.solution",
        "peekOfCode": "def drawRectangle(canvas, r):\n    x, y, x1, y1 = r\n    canvas[x][y], canvas[x][y1 + y], canvas[x1][y], canvas[x1][y + y1] = [\"*\"] * 4\n    for j in range(y + 1, y + y1):\n        canvas[x][j] = \"|\"\n        canvas[x1][j] = \"|\"\n    return canvas\ncanvas = [\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],",
        "detail": "practice.drawRectangle.solution",
        "documentation": {}
    },
    {
        "label": "canvas",
        "kind": 5,
        "importPath": "practice.drawRectangle.solution",
        "description": "practice.drawRectangle.solution",
        "peekOfCode": "canvas = [\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"],\n    [\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\"],\n    [\"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\", \"b\"],\n]\nrectangle = [1, 1, 4, 3]\nprint(drawRectangle(canvas, rectangle))",
        "detail": "practice.drawRectangle.solution",
        "documentation": {}
    },
    {
        "label": "rectangle",
        "kind": 5,
        "importPath": "practice.drawRectangle.solution",
        "description": "practice.drawRectangle.solution",
        "peekOfCode": "rectangle = [1, 1, 4, 3]\nprint(drawRectangle(canvas, rectangle))",
        "detail": "practice.drawRectangle.solution",
        "documentation": {}
    },
    {
        "label": "fib",
        "kind": 2,
        "importPath": "practice.Fibonacci.solution",
        "description": "practice.Fibonacci.solution",
        "peekOfCode": "def fib(N):\n    \"\"\"\n    Avoid redoing the something over and over and store any Fib in a dictionary\n    to not do it again\n    Time: o(n)\n    \"\"\"\n    memo = {}\n    if N in memo:\n        return memo[N]\n    if N <= 2:",
        "detail": "practice.Fibonacci.solution",
        "documentation": {}
    },
    {
        "label": "fileNaming",
        "kind": 2,
        "importPath": "practice.fileNaming.solution",
        "description": "practice.fileNaming.solution",
        "peekOfCode": "def fileNaming(names):\n    for i in range(1, len(names)):\n        temp = names[i]\n        counter = 1\n        while temp in names[0:i]:\n            temp = f\"{names[i]}({counter})\"\n            counter += 1\n        names[i] = temp\n    return names\nprint(fileNaming([\"doc\", \"doc\", \"image\", \"doc(1)\", \"doc\"]))",
        "detail": "practice.fileNaming.solution",
        "documentation": {}
    },
    {
        "label": "check_mat",
        "kind": 2,
        "importPath": "practice.GoogleCodeJam.lat_mat",
        "description": "practice.GoogleCodeJam.lat_mat",
        "peekOfCode": "def check_mat(m):\n    d_sum = 0\n    r_rows = 0\n    r_col = 0\n    c_rep = {}\n    for i in range(len(m)):\n        rep = {}\n        for j in range(len(m)):\n            ele = m[i][j]\n            if i == j:",
        "detail": "practice.GoogleCodeJam.lat_mat",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "practice.GoogleCodeJam.lat_mat",
        "description": "practice.GoogleCodeJam.lat_mat",
        "peekOfCode": "t = int(input())  # read a line with a single integer\nfor i in range(1, t + 1):\n    m = []\n    rows = int(input())\n    for i in range(1, rows + 1):\n        m.append([int(s) for s in input().split(\" \")])",
        "detail": "practice.GoogleCodeJam.lat_mat",
        "documentation": {}
    },
    {
        "label": "nestingDepth",
        "kind": 2,
        "importPath": "practice.GoogleCodeJam.nesting_depth",
        "description": "practice.GoogleCodeJam.nesting_depth",
        "peekOfCode": "def nestingDepth(s):\n    l = re.findall(r\"(0+|1+|2+|3+|4+|5+|6+|7+|8+|9+)\", s)\n    out = \"\"\n    open_p = 0\n    for i in range(len(l)):\n        n = int(l[i][0])\n        if open_p < n:\n            new_p = n - open_p\n            out += \"(\" * new_p + l[i]\n            open_p += new_p",
        "detail": "practice.GoogleCodeJam.nesting_depth",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "practice.GoogleCodeJam.nesting_depth",
        "description": "practice.GoogleCodeJam.nesting_depth",
        "peekOfCode": "t = int(input())  # read a line with a single integer\nfor i in range(1, t + 1):\n    s = input()\n    print(\"Case #{}: {}\".format(i, nestingDepth(s)))",
        "detail": "practice.GoogleCodeJam.nesting_depth",
        "documentation": {}
    },
    {
        "label": "partneringReturn",
        "kind": 2,
        "importPath": "practice.GoogleCodeJam.parenting_partnering_returns",
        "description": "practice.GoogleCodeJam.parenting_partnering_returns",
        "peekOfCode": "def partneringReturn(ts):\n    ts = sorted(ts, key=lambda x: [x[0], x[1]])\n    j = [ts[0]]\n    c = [ts[1]]\n    p = \"JC\"\n    for i in range(2, len(ts)):\n        if j[-1][1] <= ts[i][0] and j[-1][0] < ts[i][0]:\n            j.append(ts[i])\n            p += \"J\"\n        elif c[-1][1] <= ts[i][0] and j[-1][0] < ts[i][0]:",
        "detail": "practice.GoogleCodeJam.parenting_partnering_returns",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "practice.GoogleCodeJam.parenting_partnering_returns",
        "description": "practice.GoogleCodeJam.parenting_partnering_returns",
        "peekOfCode": "t = int(input())  # read a line with a single integer\nfor i in range(1, t + 1):\n    tasks = []\n    rows = int(input())\n    for _ in range(1, rows + 1):\n        tasks.append([int(s) for s in input().split(\" \")])\n    print(\"Case #{}: {}\".format(i, partneringReturn(tasks)))",
        "detail": "practice.GoogleCodeJam.parenting_partnering_returns",
        "documentation": {}
    },
    {
        "label": "showFruits",
        "kind": 2,
        "importPath": "practice.GoogleCodeJam.test",
        "description": "practice.GoogleCodeJam.test",
        "peekOfCode": "def showFruits(d):\n    fruits = sorted(d, key=lambda x: x[0])\n    out = []\n    for fruit in fruits:\n        l = min(d[fruit])\n        h = max(d[fruit])\n        m = sum(d[fruit]) // len(d[fruit])\n        out.append(f\"{fruit} {l} {h} {m}\")\n    return out\nloops = int(input())",
        "detail": "practice.GoogleCodeJam.test",
        "documentation": {}
    },
    {
        "label": "loops",
        "kind": 5,
        "importPath": "practice.GoogleCodeJam.test",
        "description": "practice.GoogleCodeJam.test",
        "peekOfCode": "loops = int(input())\nfor i in range(1, loops + 1):\n    d = defaultdict(list)\n    input()\n    no_of_products = int(input())\n    for _ in range(no_of_products):\n        food = input().split(\" \")\n        d[food[0]].append(int(food[1]))\n    print(\"Case #{}:\".format(i))\n    for item in showFruits(d):",
        "detail": "practice.GoogleCodeJam.test",
        "documentation": {}
    },
    {
        "label": "check",
        "kind": 2,
        "importPath": "practice.isItPossible.solution",
        "description": "practice.isItPossible.solution",
        "peekOfCode": "def check(first, second, target):\n    while first < target:\n        first += second\n    return first\ndef isPossible(a, b, c, d):\n    # Write your code here\n    if c < d:\n        a = check(a, b, c)\n        b = check(b, a, d)\n    else:",
        "detail": "practice.isItPossible.solution",
        "documentation": {}
    },
    {
        "label": "isPossible",
        "kind": 2,
        "importPath": "practice.isItPossible.solution",
        "description": "practice.isItPossible.solution",
        "peekOfCode": "def isPossible(a, b, c, d):\n    # Write your code here\n    if c < d:\n        a = check(a, b, c)\n        b = check(b, a, d)\n    else:\n        b = check(b, a, d)\n        a = check(a, b, c)\n    if a != c or b != d:\n        return \"No\"",
        "detail": "practice.isItPossible.solution",
        "documentation": {}
    },
    {
        "label": "island",
        "kind": 2,
        "importPath": "practice.Island.solution",
        "description": "practice.Island.solution",
        "peekOfCode": "def island(matrix):\n    \"\"\"\n    given a two by two matrix, get the number of islands in it, an island is a series of 1's connected in a\n    row or a column\n    \"\"\"\n    if (not matrix) or len(matrix) == 0:\n        return 0\n    number_of_islands = 0\n    l = [True] * len(matrix[0])\n    for i in range(len(matrix)):",
        "detail": "practice.Island.solution",
        "documentation": {}
    },
    {
        "label": "isLucky",
        "kind": 2,
        "importPath": "practice.isLucky.solution",
        "description": "practice.isLucky.solution",
        "peekOfCode": "def isLucky(n):\n    \"\"\"\n    isLucky takes in an integer and return True if the sum of its right half == sum of the\n     right half\n    :param n:\n    :return:\n    \"\"\"\n    # l = list(map(int, str(n)))\n    # return sum(l[0:len(l) // 2]) == sum(l[len(l) // 2:])\n    s = str(n)",
        "detail": "practice.isLucky.solution",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "practice.isLucky.solution",
        "description": "practice.isLucky.solution",
        "peekOfCode": "n = 1230\nprint(isLucky(n))",
        "detail": "practice.isLucky.solution",
        "documentation": {}
    },
    {
        "label": "singleNumber",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_1.singleNumber",
        "description": "practice.leetCode_30DaysOfCode.day_1.singleNumber",
        "peekOfCode": "def singleNumber(nums):\n    \"\"\"\n    given a list of integer with every element appears twice and a single number appears once, return the value of the\n    single number\n    \"\"\"\n    count = Counter(nums)\n    for k, v in count.items():\n        if v == 1:\n            return k\nprint(singleNumber([2, 2, 4, 1, 5]))",
        "detail": "practice.leetCode_30DaysOfCode.day_1.singleNumber",
        "documentation": {}
    },
    {
        "label": "deleteDuplicates",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_10.delete_duplicates_from_linked_list",
        "description": "practice.leetCode_30DaysOfCode.day_10.delete_duplicates_from_linked_list",
        "peekOfCode": "def deleteDuplicates(self, head):\n    current = head\n    while current:\n        # case_1 if the head is duplicate\n        if current.next and current.val == current.next.val:\n            head = current.next.next\n            while head and current.val == head.val:\n                head = head.next\n            current = head\n        # case_2 if nodes are duplicate after the head",
        "detail": "practice.leetCode_30DaysOfCode.day_10.delete_duplicates_from_linked_list",
        "documentation": {}
    },
    {
        "label": "MinStack",
        "kind": 6,
        "importPath": "practice.leetCode_30DaysOfCode.day_10.stack_implementation",
        "description": "practice.leetCode_30DaysOfCode.day_10.stack_implementation",
        "peekOfCode": "class MinStack:\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.stack = []\n    def push(self, x: int) -> None:\n        # store every element as a pair (element, min_so_far)\n        if len(self.stack) == 0:\n            self.stack.append([x, x])",
        "detail": "practice.leetCode_30DaysOfCode.day_10.stack_implementation",
        "documentation": {}
    },
    {
        "label": "minStack",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.day_10.stack_implementation",
        "description": "practice.leetCode_30DaysOfCode.day_10.stack_implementation",
        "peekOfCode": "minStack = MinStack()\nminStack.push(-2)\nminStack.push(0)\nminStack.push(-3)\nminStack.getMin()\nminStack.pop()\nminStack.top()\nminStack.getMin()",
        "detail": "practice.leetCode_30DaysOfCode.day_10.stack_implementation",
        "documentation": {}
    },
    {
        "label": "binarySearch",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_11.binary_search_rec",
        "description": "practice.leetCode_30DaysOfCode.day_11.binary_search_rec",
        "peekOfCode": "def binarySearch(arr, val):\n    # base case when the array is empty\n    if len(arr) == 0:\n        return False\n    # find the mid point of the array\n    mid = len(arr) // 2\n    if arr[mid] == val:\n        return True\n    # if the value of the mid point is greater than the val to search for, call the binarySearch fun with the first\n    # half of the array",
        "detail": "practice.leetCode_30DaysOfCode.day_11.binary_search_rec",
        "documentation": {}
    },
    {
        "label": "diameterOfBinaryTree",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_11.diameter_of_binary_tree",
        "description": "practice.leetCode_30DaysOfCode.day_11.diameter_of_binary_tree",
        "peekOfCode": "def diameterOfBinaryTree(root):\n    find_height(root, diameter)\n    return diameter\ndef find_height(root, diameter):\n    if root == None:\n        return 0\n    if root.left == None and root.right == None:\n        return 1\n    l_height = find_height(root.left, diameter)\n    r_height = find_height(root.right, diameter)",
        "detail": "practice.leetCode_30DaysOfCode.day_11.diameter_of_binary_tree",
        "documentation": {}
    },
    {
        "label": "find_height",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_11.diameter_of_binary_tree",
        "description": "practice.leetCode_30DaysOfCode.day_11.diameter_of_binary_tree",
        "peekOfCode": "def find_height(root, diameter):\n    if root == None:\n        return 0\n    if root.left == None and root.right == None:\n        return 1\n    l_height = find_height(root.left, diameter)\n    r_height = find_height(root.right, diameter)\n    total = l_height + r_height\n    if total > diameter:\n        diameter = total",
        "detail": "practice.leetCode_30DaysOfCode.day_11.diameter_of_binary_tree",
        "documentation": {}
    },
    {
        "label": "diameter",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.day_11.diameter_of_binary_tree",
        "description": "practice.leetCode_30DaysOfCode.day_11.diameter_of_binary_tree",
        "peekOfCode": "diameter = 0\ndef diameterOfBinaryTree(root):\n    find_height(root, diameter)\n    return diameter\ndef find_height(root, diameter):\n    if root == None:\n        return 0\n    if root.left == None and root.right == None:\n        return 1\n    l_height = find_height(root.left, diameter)",
        "detail": "practice.leetCode_30DaysOfCode.day_11.diameter_of_binary_tree",
        "documentation": {}
    },
    {
        "label": "lastStoneWeight",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_12.last_stone_weight",
        "description": "practice.leetCode_30DaysOfCode.day_12.last_stone_weight",
        "peekOfCode": "def lastStoneWeight(stones):\n    def getLast(arr):\n        # get the index of the max num\n        ind = arr.index(max(arr))\n        # swap the max with the last element to make the deletion process efficient (O(n) time and O(1) space)\n        arr[-1], arr[ind] = arr[ind], arr[-1]\n        return arr.pop()\n    while len(stones) > 1:\n        # delete the largest ele from the stones list\n        largest = getLast(stones)",
        "detail": "practice.leetCode_30DaysOfCode.day_12.last_stone_weight",
        "documentation": {}
    },
    {
        "label": "findMaxLength",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_13.Contiguous_array",
        "description": "practice.leetCode_30DaysOfCode.day_13.Contiguous_array",
        "peekOfCode": "def findMaxLength(nums):\n    d = {}\n    subarr, count = 0, 0\n    for i, v in enumerate(nums):\n        count += 2 * v - 1\n        if count == 0:\n            subarr = i + 1\n        if count in d:\n            subarr = max(subarr, i - d[count])\n        else:",
        "detail": "practice.leetCode_30DaysOfCode.day_13.Contiguous_array",
        "documentation": {}
    },
    {
        "label": "stringShift",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_14.perform_string_shifts",
        "description": "practice.leetCode_30DaysOfCode.day_14.perform_string_shifts",
        "peekOfCode": "def stringShift(s, shift_arr):\n    \"\"\"\n    stringShift takes in a string and performs a list of rotations to it\n    :param s: an input string\n    :param shift_arr: an array of all shift operations to be performed to the string\n    :return: return the final string after rotation\n    \"\"\"\n    # # solution_1 loop through all shift operations and perform them\n    # # timeComplexity: O(n * m) where m is the number of operations\n    # dq = deque(s)",
        "detail": "practice.leetCode_30DaysOfCode.day_14.perform_string_shifts",
        "documentation": {}
    },
    {
        "label": "productExceptSelf",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_15.product_of_array",
        "description": "practice.leetCode_30DaysOfCode.day_15.product_of_array",
        "peekOfCode": "def productExceptSelf(nums):\n    # create ans array to store the left product of every element and them multi it by the right product\n    ans = [0] * len(nums)\n    ans[0] = 1\n    for i in range(1, len(nums)):\n        ans[i] = ans[i - 1] * nums[i - 1]\n    r = 1\n    for i in range(len(nums) - 1, -1, -1):\n        ans[i] = ans[i] * r\n        r *= nums[i]",
        "detail": "practice.leetCode_30DaysOfCode.day_15.product_of_array",
        "documentation": {}
    },
    {
        "label": "checkValidString",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_16.balance+paranteses",
        "description": "practice.leetCode_30DaysOfCode.day_16.balance+paranteses",
        "peekOfCode": "def checkValidString(s):\n    \"\"\"\n    TimeComplexity: O(n)\n    SpaceComplexity: O(1)\n    \"\"\"\n    used_stars = 0\n    unused_stars = 0\n    open_p = 0\n    for p in s:\n        if p == \"(\":",
        "detail": "practice.leetCode_30DaysOfCode.day_16.balance+paranteses",
        "documentation": {}
    },
    {
        "label": "numIslands",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_17.number_of_islands",
        "description": "practice.leetCode_30DaysOfCode.day_17.number_of_islands",
        "peekOfCode": "def numIslands(grid):\n    if grid is None and len(grid) == 0:\n        return 0\n    nuOfIslands = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[i])):\n            if grid[i][j] == \"1\":\n                nuOfIslands += 1\n                dfs(grid, i, j)\n    return nuOfIslands",
        "detail": "practice.leetCode_30DaysOfCode.day_17.number_of_islands",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_17.number_of_islands",
        "description": "practice.leetCode_30DaysOfCode.day_17.number_of_islands",
        "peekOfCode": "def dfs(grid, i, j):\n    if (\n        (j >= len(grid[0]))\n        or (j < 0)\n        or (i < 0)\n        or (i >= len(grid))\n        or (grid[i][j] != \"1\")\n    ):\n        return 0\n    grid[i][j] = 0",
        "detail": "practice.leetCode_30DaysOfCode.day_17.number_of_islands",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.day_17.number_of_islands",
        "description": "practice.leetCode_30DaysOfCode.day_17.number_of_islands",
        "peekOfCode": "grid = [[\"1\", \"1\", \"0\"], [\"1\", \"1\", \"0\"], [\"0\", \"0\", \"1\"], [\"0\", \"0\", \"0\"]]\nprint(numIslands(grid))",
        "detail": "practice.leetCode_30DaysOfCode.day_17.number_of_islands",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_19.search_in_rotated_sorted_array",
        "description": "practice.leetCode_30DaysOfCode.day_19.search_in_rotated_sorted_array",
        "peekOfCode": "def main(nums, target):\n    # left pointer\n    l = 0\n    # right pointer\n    r = len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid\n        # if the first half of the array is sorted",
        "detail": "practice.leetCode_30DaysOfCode.day_19.search_in_rotated_sorted_array",
        "documentation": {}
    },
    {
        "label": "isHappy",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_2.happyNumber",
        "description": "practice.leetCode_30DaysOfCode.day_2.happyNumber",
        "peekOfCode": "def isHappy(n):\n    \"\"\"\n    Is happy takes in a number and returns True if it is a happy number, False otherwise. A happy number\n    is a number defined by the following process: Starting with any positive integer, replace the number by the\n    sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),\n    or it loops endlessly in a cycle which does not include 1.\n    \"\"\"\n    seen = {n: 1}\n    while True:\n        new_sq = sum([int(d) ** 2 for d in str(n)])",
        "detail": "practice.leetCode_30DaysOfCode.day_2.happyNumber",
        "documentation": {}
    },
    {
        "label": "memo",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.day_2.happyNumber",
        "description": "practice.leetCode_30DaysOfCode.day_2.happyNumber",
        "peekOfCode": "memo = {}\ndef isHappy(n):\n    \"\"\"\n    Is happy takes in a number and returns True if it is a happy number, False otherwise. A happy number\n    is a number defined by the following process: Starting with any positive integer, replace the number by the\n    sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),\n    or it loops endlessly in a cycle which does not include 1.\n    \"\"\"\n    seen = {n: 1}\n    while True:",
        "detail": "practice.leetCode_30DaysOfCode.day_2.happyNumber",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "description": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def bstFromPreorder(self, preorder):\n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])",
        "detail": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "description": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "peekOfCode": "class Solution:\n    def bstFromPreorder(self, preorder):\n        if not preorder:\n            return None\n        root = TreeNode(preorder[0])\n        i = 1\n        while i < len(preorder) and preorder[i] < root.val:\n            i += 1\n        root.left = self.bstFromPreorder(preorder[1:i])\n        root.right = self.bstFromPreorder(preorder[i:])",
        "detail": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "documentation": {}
    },
    {
        "label": "preorder",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "description": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "peekOfCode": "preorder = [19, 4, 8, 11]\nbst = Solution()\nbst.bstFromPreorder(preorder)",
        "detail": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "documentation": {}
    },
    {
        "label": "bst",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "description": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "peekOfCode": "bst = Solution()\nbst.bstFromPreorder(preorder)",
        "detail": "practice.leetCode_30DaysOfCode.day_20.create_BST_from_preorder",
        "documentation": {}
    },
    {
        "label": "jobSeq",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_25.job_seqquencing",
        "description": "practice.leetCode_30DaysOfCode.day_25.job_seqquencing",
        "peekOfCode": "def jobSeq(profit, deadline):\n    \"\"\"\n    :param profit: sorted list represents the profit gained from each task if done.\n    :param deadline: unsorted list represents the deadline for each task.\n    :return: max profit possible from a set of tasks given their deadline\n    \"\"\"\n    free_slots = max(deadline)\n    slots = [0] * free_slots\n    ans = 0\n    for i in range(len(profit)):",
        "detail": "practice.leetCode_30DaysOfCode.day_25.job_seqquencing",
        "documentation": {}
    },
    {
        "label": "profit",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.day_25.job_seqquencing",
        "description": "practice.leetCode_30DaysOfCode.day_25.job_seqquencing",
        "peekOfCode": "profit = [35, 40, 25, 20, 15, 10]\ndeadline = [3, 4, 4, 2, 3, 1]\nprint(jobSeq(profit, deadline))",
        "detail": "practice.leetCode_30DaysOfCode.day_25.job_seqquencing",
        "documentation": {}
    },
    {
        "label": "deadline",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.day_25.job_seqquencing",
        "description": "practice.leetCode_30DaysOfCode.day_25.job_seqquencing",
        "peekOfCode": "deadline = [3, 4, 4, 2, 3, 1]\nprint(jobSeq(profit, deadline))",
        "detail": "practice.leetCode_30DaysOfCode.day_25.job_seqquencing",
        "documentation": {}
    },
    {
        "label": "maxSubArray",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_3.max_sub_array",
        "description": "practice.leetCode_30DaysOfCode.day_3.max_sub_array",
        "peekOfCode": "def maxSubArray(arr):\n    \"\"\"\n    return the max value of any subarray in the given array\n    \"\"\"\n    max_so_far = arr[0]\n    curr_max = max_so_far\n    for i in range(1, len(arr)):\n        curr_max += arr[i]\n        if curr_max < arr[i]:\n            curr_max = arr[i]",
        "detail": "practice.leetCode_30DaysOfCode.day_3.max_sub_array",
        "documentation": {}
    },
    {
        "label": "findShortestSubArray",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_3.shortest_dist",
        "description": "practice.leetCode_30DaysOfCode.day_3.shortest_dist",
        "peekOfCode": "def findShortestSubArray(nums):\n    shortest_dist = len(nums)\n    max_counts = 1\n    d = {}\n    for i in range(len(nums)):\n        if nums[i] in d:\n            d[nums[i]][0] += 1\n            if d[nums[i]][0] > max_counts:\n                shortest_dist = i - d[nums[i]][1]\n                max_counts = d[nums[i]][0]",
        "detail": "practice.leetCode_30DaysOfCode.day_3.shortest_dist",
        "documentation": {}
    },
    {
        "label": "maxProduct",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_4.max_product_sum",
        "description": "practice.leetCode_30DaysOfCode.day_4.max_product_sum",
        "peekOfCode": "def maxProduct(nums):\n    max_so_far = nums[0]\n    curr_max = max_so_far\n    for i in range(1, len(nums)):\n        curr_max *= nums[i]\n        if curr_max < nums[i]:\n            curr_max = nums[i]\n        if curr_max > max_so_far:\n            max_so_far = curr_max\n    return max_so_far",
        "detail": "practice.leetCode_30DaysOfCode.day_4.max_product_sum",
        "documentation": {}
    },
    {
        "label": "moveZeroes",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_4.remove_zeros",
        "description": "practice.leetCode_30DaysOfCode.day_4.remove_zeros",
        "peekOfCode": "def moveZeroes(nums):\n    \"\"\"\n    Move all zeros to the end of the given array (nums) with keeping the order of other elements.\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    # counter = 0\n    # for i in range(len(nums) - 1):\n    #     if nums[counter] == 0:\n    #         nums.pop(counter)\n    #         nums.append(0)",
        "detail": "practice.leetCode_30DaysOfCode.day_4.remove_zeros",
        "documentation": {}
    },
    {
        "label": "maxProfit",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_5.best_time_to_Buy_and_Sell_Stock",
        "description": "practice.leetCode_30DaysOfCode.day_5.best_time_to_Buy_and_Sell_Stock",
        "peekOfCode": "def maxProfit(prices):\n    i = 0\n    max_profit = 0\n    while i < len(prices) - 1:\n        while i < len(prices) - 1 and prices[i] >= prices[i + 1]:\n            i += 1\n        min_pri = prices[i]\n        while i < len(prices) - 1 and prices[i] <= prices[i + 1]:\n            i += 1\n        max_pri = prices[i]",
        "detail": "practice.leetCode_30DaysOfCode.day_5.best_time_to_Buy_and_Sell_Stock",
        "documentation": {}
    },
    {
        "label": "buddyStrings",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_5.buddy_strings",
        "description": "practice.leetCode_30DaysOfCode.day_5.buddy_strings",
        "peekOfCode": "def buddyStrings(A, B):\n    if len(A) != len(B):\n        return False\n    elif A == B:\n        seen = set()\n        for char in A:\n            if char in seen:\n                return True\n            seen.add(char)\n        return False",
        "detail": "practice.leetCode_30DaysOfCode.day_5.buddy_strings",
        "documentation": {}
    },
    {
        "label": "groupAnagrams",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_6.group_anagrams",
        "description": "practice.leetCode_30DaysOfCode.day_6.group_anagrams",
        "peekOfCode": "def groupAnagrams(strs):\n    # \"\"\"\n    # TimeComplexity: O(n*K*log(K)) where n is the length of strs and K is the length of the longest string\n    #  in strs\n    # \"\"\"\n    # seen = {}\n    # for s in strs:\n    #     ele = tuple((sorted(s)))\n    #     if ele in seen:\n    #         seen[ele].append(s)",
        "detail": "practice.leetCode_30DaysOfCode.day_6.group_anagrams",
        "documentation": {}
    },
    {
        "label": "countElements",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_7.counting_elements",
        "description": "practice.leetCode_30DaysOfCode.day_7.counting_elements",
        "peekOfCode": "def countElements(arr):\n    # use a set to store all unique elements in the array\n    in_arr = set(arr)\n    ans = 0\n    # loop through all elements in the array because duplicated are counted separately\n    for n in arr:\n        # if the number + 1 in the set (checking an element in a set takes O(1) time)\n        if n + 1 in in_arr:\n            ans += 1\n    return ans",
        "detail": "practice.leetCode_30DaysOfCode.day_7.counting_elements",
        "documentation": {}
    },
    {
        "label": "maxHeapify",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_7.sort_colors",
        "description": "practice.leetCode_30DaysOfCode.day_7.sort_colors",
        "peekOfCode": "def maxHeapify(arr, len_arr, i):\n    f_child = 2 * i + 1\n    s_child = 2 * i + 2\n    # get the smallest value between the first and second child\n    # if first child exists\n    if f_child < len_arr:\n        largest = f_child\n        # if second child exists and less than the first child\n        if s_child < len_arr and arr[f_child] < arr[s_child]:\n            largest = s_child",
        "detail": "practice.leetCode_30DaysOfCode.day_7.sort_colors",
        "documentation": {}
    },
    {
        "label": "sortColors",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_7.sort_colors",
        "description": "practice.leetCode_30DaysOfCode.day_7.sort_colors",
        "peekOfCode": "def sortColors(nums):\n    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    # create a max-heap\n    # create a max-heap\n    for i in range(len(nums) // 2 - 1, -1, -1):\n        maxHeapify(nums, len(nums), i)\n    for i in range(len(nums) - 1, -1, -1):\n        nums[i], nums[0] = nums[0], nums[i]",
        "detail": "practice.leetCode_30DaysOfCode.day_7.sort_colors",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "practice.leetCode_30DaysOfCode.day_8.mid_of_linkedList",
        "description": "practice.leetCode_30DaysOfCode.day_8.mid_of_linkedList",
        "peekOfCode": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        get_len = 0\n        current = head\n        while current:\n            get_len += 1",
        "detail": "practice.leetCode_30DaysOfCode.day_8.mid_of_linkedList",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "practice.leetCode_30DaysOfCode.day_8.mid_of_linkedList",
        "description": "practice.leetCode_30DaysOfCode.day_8.mid_of_linkedList",
        "peekOfCode": "class Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        get_len = 0\n        current = head\n        while current:\n            get_len += 1\n            current = current.next\n        mid = get_len // 2\n        current = head\n        while mid > 0:",
        "detail": "practice.leetCode_30DaysOfCode.day_8.mid_of_linkedList",
        "documentation": {}
    },
    {
        "label": "backspaceCompare",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_9.backspace_string_compare",
        "description": "practice.leetCode_30DaysOfCode.day_9.backspace_string_compare",
        "peekOfCode": "def backspaceCompare(S, T):\n    return __helperFunc(S) == __helperFunc(T)\ndef __helperFunc(s):\n    stack = []\n    for ele in s:\n        if ele != \"#\":\n            stack.append(ele)\n        else:\n            if len(stack) > 0:\n                stack.pop()",
        "detail": "practice.leetCode_30DaysOfCode.day_9.backspace_string_compare",
        "documentation": {}
    },
    {
        "label": "removeDuplicates",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_9.remove_duplicates_2",
        "description": "practice.leetCode_30DaysOfCode.day_9.remove_duplicates_2",
        "peekOfCode": "def removeDuplicates(nums):\n    i = 0\n    # counter the number of duplicate numbers\n    counter = 1\n    for j in range(1, len(nums)):\n        # if the two numbers are different\n        if nums[i] != nums[j]:\n            # swap\n            i = swapHelper(i + 1, j, nums)\n            # set the counter to one again since we have a new num",
        "detail": "practice.leetCode_30DaysOfCode.day_9.remove_duplicates_2",
        "documentation": {}
    },
    {
        "label": "swapHelper",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_9.remove_duplicates_2",
        "description": "practice.leetCode_30DaysOfCode.day_9.remove_duplicates_2",
        "peekOfCode": "def swapHelper(i, j, nums):\n    nums[i], nums[j] = nums[j], nums[i]\n    return i\nprint(removeDuplicates([1, 1, 1, 2, 2, 2, 4, 4, 4]))",
        "detail": "practice.leetCode_30DaysOfCode.day_9.remove_duplicates_2",
        "documentation": {}
    },
    {
        "label": "removeDuplicates",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.day_9.remove_duplicates_from_sorted_array",
        "description": "practice.leetCode_30DaysOfCode.day_9.remove_duplicates_from_sorted_array",
        "peekOfCode": "def removeDuplicates(nums):\n    \"\"\"\n    TimeComplexity: O(n)\n    SpaceComplexity: O(1)\n    \"\"\"\n    i = 0\n    for j in range(len(nums)):\n        if nums[i] != nums[j]:\n            i += 1\n            nums[i], nums[j] = nums[j], nums[i]",
        "detail": "practice.leetCode_30DaysOfCode.day_9.remove_duplicates_from_sorted_array",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.all_and_any",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.all_and_any",
        "peekOfCode": "l = [1, 2, 3, 4, 0]\n# using any evaluates some values and get true if any is true\nprint(any(l))\nprint(all(l))",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.all_and_any",
        "documentation": {}
    },
    {
        "label": "DecoratorExample",
        "kind": 6,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.instance_class_static_methods",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.instance_class_static_methods",
        "peekOfCode": "class DecoratorExample:\n    name = \"ahmed\"\n    def __init__(self, age):\n        self.age = age\n    @staticmethod\n    def staticMethod():\n        return \"I am inside the static method\"\n    # instance method\n    def show_name(self):\n        return self.name",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.instance_class_static_methods",
        "documentation": {}
    },
    {
        "label": "ins",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.instance_class_static_methods",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.instance_class_static_methods",
        "peekOfCode": "ins = DecoratorExample(\"ahmed\")\nprint(ins.show_name())\nprint(ins.class_method(\"mohamed\"))\nprint(ins.staticMethod())\n# # example on the class methods to create instances of the class\n# import re\n# class Students:\n#     \"\"\"\n#     Students class takes in a string with the name-student_id-grade and returns a list of all of the student data ready\n#     to be added to the DB",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.instance_class_static_methods",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "peekOfCode": "color = (20, 40, 60)\n# print the red color\nprint(color[0])\n# use a named tuple for better readability because of the object notation it has\nColor = namedtuple(\"Color\", [\"red\", \"green\", \"blue\"])\ncolor = Color(20, 40, 60)\n# you can use object notation or indexing to extract data\nprint(color.red)\nprint(color[0])\n# However, as with tuples, attributes in named tuples are immutable. it has the _replace method to change values",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "documentation": {}
    },
    {
        "label": "Color",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "peekOfCode": "Color = namedtuple(\"Color\", [\"red\", \"green\", \"blue\"])\ncolor = Color(20, 40, 60)\n# you can use object notation or indexing to extract data\nprint(color.red)\nprint(color[0])\n# However, as with tuples, attributes in named tuples are immutable. it has the _replace method to change values\ncolor = color._replace(red=200)\n# Named Tuple can be transformed to dict\nprint(color._asdict())",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "peekOfCode": "color = Color(20, 40, 60)\n# you can use object notation or indexing to extract data\nprint(color.red)\nprint(color[0])\n# However, as with tuples, attributes in named tuples are immutable. it has the _replace method to change values\ncolor = color._replace(red=200)\n# Named Tuple can be transformed to dict\nprint(color._asdict())",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "peekOfCode": "color = color._replace(red=200)\n# Named Tuple can be transformed to dict\nprint(color._asdict())",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.named_tuple",
        "documentation": {}
    },
    {
        "label": "grades_state",
        "kind": 2,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "peekOfCode": "def grades_state(*args, **kwargs):\n    \"\"\"\n    grades_state(grades) --> takes in students grades and returns the state of the grade, pass, fail, fucked up.\n    :param grades: a list of integers represents the students grades\n    :return: a string that represents the state of the student\n    \"\"\"\n    for grade in args:\n        print(grade)\n    print(kwargs)\nprint(grades_state.__doc__)",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "peekOfCode": "nums = [1, 2, 3, 4, 5, 6, 7]\n# get all positive value, (x % 2 == 0) is true for all positive values\npos_val = list(filter(lambda x: x % 2 == 0, nums))\nprint(pos_val)\nnames = [\"AHMED\", \"mohamed\", \"khaled\"]\n# get all element with upper case in the list\nupper_names = list(filter(lambda name: name.isupper(), names))\nprint(upper_names)\n\"\"\"\n2- map(fun, iterable), applies the fun to every val in the iterable ",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "documentation": {}
    },
    {
        "label": "pos_val",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "peekOfCode": "pos_val = list(filter(lambda x: x % 2 == 0, nums))\nprint(pos_val)\nnames = [\"AHMED\", \"mohamed\", \"khaled\"]\n# get all element with upper case in the list\nupper_names = list(filter(lambda name: name.isupper(), names))\nprint(upper_names)\n\"\"\"\n2- map(fun, iterable), applies the fun to every val in the iterable \n\"\"\"\nstr_nums = [\"1\", \"2\", \"3\", \"4\"]",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "documentation": {}
    },
    {
        "label": "names",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "peekOfCode": "names = [\"AHMED\", \"mohamed\", \"khaled\"]\n# get all element with upper case in the list\nupper_names = list(filter(lambda name: name.isupper(), names))\nprint(upper_names)\n\"\"\"\n2- map(fun, iterable), applies the fun to every val in the iterable \n\"\"\"\nstr_nums = [\"1\", \"2\", \"3\", \"4\"]\nint_nums = list(map(int, str_nums))\nprint(int_nums)",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "documentation": {}
    },
    {
        "label": "upper_names",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "peekOfCode": "upper_names = list(filter(lambda name: name.isupper(), names))\nprint(upper_names)\n\"\"\"\n2- map(fun, iterable), applies the fun to every val in the iterable \n\"\"\"\nstr_nums = [\"1\", \"2\", \"3\", \"4\"]\nint_nums = list(map(int, str_nums))\nprint(int_nums)\n# convert grades to pass, fail\ngrades = [70, 50, 20, 40]",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "documentation": {}
    },
    {
        "label": "str_nums",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "peekOfCode": "str_nums = [\"1\", \"2\", \"3\", \"4\"]\nint_nums = list(map(int, str_nums))\nprint(int_nums)\n# convert grades to pass, fail\ngrades = [70, 50, 20, 40]\nfinal = list(\n    map(lambda x: \"pass\" if x > 50 else \"fail\" if x > 30 else \"FUCKED UP\", grades)\n)\nprint(final)\n\"\"\"",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "documentation": {}
    },
    {
        "label": "int_nums",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "peekOfCode": "int_nums = list(map(int, str_nums))\nprint(int_nums)\n# convert grades to pass, fail\ngrades = [70, 50, 20, 40]\nfinal = list(\n    map(lambda x: \"pass\" if x > 50 else \"fail\" if x > 30 else \"FUCKED UP\", grades)\n)\nprint(final)\n\"\"\"\nwrite documentation for my function ",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "documentation": {}
    },
    {
        "label": "grades",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "peekOfCode": "grades = [70, 50, 20, 40]\nfinal = list(\n    map(lambda x: \"pass\" if x > 50 else \"fail\" if x > 30 else \"FUCKED UP\", grades)\n)\nprint(final)\n\"\"\"\nwrite documentation for my function \n\"\"\"\ndef grades_state(*args, **kwargs):\n    \"\"\"",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "documentation": {}
    },
    {
        "label": "final",
        "kind": 5,
        "importPath": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "description": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "peekOfCode": "final = list(\n    map(lambda x: \"pass\" if x > 50 else \"fail\" if x > 30 else \"FUCKED UP\", grades)\n)\nprint(final)\n\"\"\"\nwrite documentation for my function \n\"\"\"\ndef grades_state(*args, **kwargs):\n    \"\"\"\n    grades_state(grades) --> takes in students grades and returns the state of the grade, pass, fail, fucked up.",
        "detail": "practice.leetCode_30DaysOfCode.Knowelege.transform",
        "documentation": {}
    },
    {
        "label": "getLargestString",
        "kind": 2,
        "importPath": "practice.Lexicographical_Maximum_String.solution",
        "description": "practice.Lexicographical_Maximum_String.solution",
        "peekOfCode": "def getLargestString(s, k):\n    d = Counter(s)\n    ord_s = sorted(d.keys(), reverse=True)\n    out = \"\"\n    l_p = 0\n    while l_p < len(ord_s):\n        if d[ord_s[l_p]] < k:\n            out += ord_s[l_p] * d[ord_s[l_p]]\n            l_p += 1\n            continue",
        "detail": "practice.Lexicographical_Maximum_String.solution",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "practice.Lexicographical_Maximum_String.solution",
        "description": "practice.Lexicographical_Maximum_String.solution",
        "peekOfCode": "s = \"xxzzxx\"\nprint(getLargestString(s, 4))",
        "detail": "practice.Lexicographical_Maximum_String.solution",
        "documentation": {}
    },
    {
        "label": "extractMatrixColumn",
        "kind": 2,
        "importPath": "practice.matrixColumn.solution",
        "description": "practice.matrixColumn.solution",
        "peekOfCode": "def extractMatrixColumn(matrix, col):\n    return [matrix[i][col] for i in range(len(matrix))]\nmatrix = [[1, 1, 1, 2], [0, 5, 0, 4], [2, 1, 3, 6]]\nprint(extractMatrixColumn(matrix, 2))",
        "detail": "practice.matrixColumn.solution",
        "documentation": {}
    },
    {
        "label": "matrix",
        "kind": 5,
        "importPath": "practice.matrixColumn.solution",
        "description": "practice.matrixColumn.solution",
        "peekOfCode": "matrix = [[1, 1, 1, 2], [0, 5, 0, 4], [2, 1, 3, 6]]\nprint(extractMatrixColumn(matrix, 2))",
        "detail": "practice.matrixColumn.solution",
        "documentation": {}
    },
    {
        "label": "matrix_elements_sum",
        "kind": 2,
        "importPath": "practice.matrixElementsSum.solution",
        "description": "practice.matrixElementsSum.solution",
        "peekOfCode": "def matrix_elements_sum(matrix):\n    hunted = []\n    total = 0\n    ran = len(matrix[0])\n    for row in matrix:\n        for no in range(ran):\n            if no in hunted:\n                continue\n            elif row[no] == 0:\n                hunted.append(no)",
        "detail": "practice.matrixElementsSum.solution",
        "documentation": {}
    },
    {
        "label": "minimumOnStack",
        "kind": 2,
        "importPath": "practice.minimumOnStack.solution",
        "description": "practice.minimumOnStack.solution",
        "peekOfCode": "def minimumOnStack(operations):\n    l = []\n    out = []\n    for i in operations:\n        if \"push\" in i:\n            l.append(int(i[i.index(\" \") + 1 :]))\n        elif \"pop\" in i:\n            l.pop()\n        else:\n            out.append(min(l))",
        "detail": "practice.minimumOnStack.solution",
        "documentation": {}
    },
    {
        "label": "operations",
        "kind": 5,
        "importPath": "practice.minimumOnStack.solution",
        "description": "practice.minimumOnStack.solution",
        "peekOfCode": "operations = [\n    \"push 10\",\n    \"min\",\n    \"push 5\",\n    \"min\",\n    \"push 8\",\n    \"min\",\n    \"pop\",\n    \"min\",\n    \"pop\",",
        "detail": "practice.minimumOnStack.solution",
        "documentation": {}
    },
    {
        "label": "minX",
        "kind": 2,
        "importPath": "practice.minStartVal.solution",
        "description": "practice.minStartVal.solution",
        "peekOfCode": "def minX(arr):\n    \"\"\"\n    given an arr, get the min number that can keep the running sum greater than or equal to 1\n    \"\"\"\n    m = min(arr)\n    if m > 0:\n        return (m * -1) + 1\n    else:\n        m = (m * -1) + 1\n    running_sum = m",
        "detail": "practice.minStartVal.solution",
        "documentation": {}
    },
    {
        "label": "arr",
        "kind": 5,
        "importPath": "practice.minStartVal.solution",
        "description": "practice.minStartVal.solution",
        "peekOfCode": "arr = [-5, -2, -4]\nprint(minX(arr))",
        "detail": "practice.minStartVal.solution",
        "documentation": {}
    },
    {
        "label": "minCost",
        "kind": 2,
        "importPath": "practice.min_weight_path.solution",
        "description": "practice.min_weight_path.solution",
        "peekOfCode": "def minCost(g_nodes, g_from, g_to, g_weight):\n    # transfer the given lists to an adjacency list\n    d = defaultdict(dict)\n    for i in range(len(g_from)):\n        if g_from[i] != g_nodes:\n            d[g_from[i]][g_to[i]] = g_weight[i]\n    if 1 not in d or g_nodes not in d[1]:\n        return 1\n    stack = [1]\n    seen = {1}",
        "detail": "practice.min_weight_path.solution",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "practice.min_weight_path.solution",
        "description": "practice.min_weight_path.solution",
        "peekOfCode": "def dfs(d, stack, seen, min_so_far, traget, c_min):\n    # base_case_1: when the stack is empty, return False, there is no such path\n    if not stack:\n        return min_so_far\n    if (stack[-1] not in d) or (traget not in d[stack[-1]]):\n        min_so_far = min(min_so_far, c_min + 1)\n        return min_so_far\n    else:\n        for vertex, weight in d[stack[-1]].items():\n            if vertex == traget:",
        "detail": "practice.min_weight_path.solution",
        "documentation": {}
    },
    {
        "label": "nthNumber",
        "kind": 2,
        "importPath": "practice.n-thNumber.solution",
        "description": "practice.n-thNumber.solution",
        "peekOfCode": "def nthNumber(s, n):\n    pattern = rf\"([0-9]+){n}\"\n    return re.match(pattern, s).group(1)\ns = \"8one 003number 201numbers li-000233le number4443\"\nn = 4\nprint(nthNumber(s, n))",
        "detail": "practice.n-thNumber.solution",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "practice.n-thNumber.solution",
        "description": "practice.n-thNumber.solution",
        "peekOfCode": "s = \"8one 003number 201numbers li-000233le number4443\"\nn = 4\nprint(nthNumber(s, n))",
        "detail": "practice.n-thNumber.solution",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "practice.n-thNumber.solution",
        "description": "practice.n-thNumber.solution",
        "peekOfCode": "n = 4\nprint(nthNumber(s, n))",
        "detail": "practice.n-thNumber.solution",
        "documentation": {}
    },
    {
        "label": "onesGroups",
        "kind": 2,
        "importPath": "practice.one_group.solution",
        "description": "practice.one_group.solution",
        "peekOfCode": "def onesGroups(grid, quires):\n    # global tot\n    ans = defaultdict(int)\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                # tot = 0\n                tot = dfs(grid, i, j, 0)\n                ans[tot] += 1\n    for i in range(len(quires)):",
        "detail": "practice.one_group.solution",
        "documentation": {}
    },
    {
        "label": "dfs",
        "kind": 2,
        "importPath": "practice.one_group.solution",
        "description": "practice.one_group.solution",
        "peekOfCode": "def dfs(grid, i, j, tot):\n    # using global tot, to not be considered in the recursive stack\n    # global tot\n    if (\n        (i < 0)\n        or (j < 0)\n        or (j >= len(grid[0]))\n        or (i >= len(grid))\n        or (grid[i][j] == 0)\n    ):",
        "detail": "practice.one_group.solution",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "practice.one_group.solution",
        "description": "practice.one_group.solution",
        "peekOfCode": "grid = [[1, 1, 1, 0, 0], [1, 1, 1, 0, 1], [0, 0, 0, 1, 0]]\nquires = [1, 2, 6]\nprint(onesGroups(grid, quires))",
        "detail": "practice.one_group.solution",
        "documentation": {}
    },
    {
        "label": "quires",
        "kind": 5,
        "importPath": "practice.one_group.solution",
        "description": "practice.one_group.solution",
        "peekOfCode": "quires = [1, 2, 6]\nprint(onesGroups(grid, quires))",
        "detail": "practice.one_group.solution",
        "documentation": {}
    },
    {
        "label": "powerOfTwo",
        "kind": 2,
        "importPath": "practice.powersOfTwo.solution",
        "description": "practice.powersOfTwo.solution",
        "peekOfCode": "def powerOfTwo(n):\n    if n < 1:\n        return []\n    l = [1]\n    i = 1\n    while i + i <= n:\n        i += i\n        l.append(i)\n    return l\nprint(powerOfTwo(10))",
        "detail": "practice.powersOfTwo.solution",
        "documentation": {}
    },
    {
        "label": "letter_combinations",
        "kind": 2,
        "importPath": "practice.pressingButtons.solution",
        "description": "practice.pressingButtons.solution",
        "peekOfCode": "def letter_combinations(digits):\n    m = {\n        \"2\": \"abc\",\n        \"3\": \"def\",\n        \"4\": \"ghi\",\n        \"5\": \"jkl\",\n        \"6\": \"mno\",\n        \"7\": \"pqrs\",\n        \"8\": \"tuv\",\n        \"9\": \"wxyz\",",
        "detail": "practice.pressingButtons.solution",
        "documentation": {}
    },
    {
        "label": "possibilities",
        "kind": 5,
        "importPath": "practice.pressingButtons.test",
        "description": "practice.pressingButtons.test",
        "peekOfCode": "possibilities = [\"ab\", \"cd\"]\nfor i in it.product(*possibilities):\n    if i:\n        print(\"\".join(i))",
        "detail": "practice.pressingButtons.test",
        "documentation": {}
    },
    {
        "label": "findLower",
        "kind": 2,
        "importPath": "practice.PsychometricTest.solution",
        "description": "practice.PsychometricTest.solution",
        "peekOfCode": "def findLower(scores, len_score, v):\n    l = 0\n    u = len_score - 1\n    while l <= u:\n        mid = (l + u) // 2\n        if scores[mid] >= v:\n            u = mid - 1\n        else:\n            l = mid + 1\n    return l",
        "detail": "practice.PsychometricTest.solution",
        "documentation": {}
    },
    {
        "label": "findUpper",
        "kind": 2,
        "importPath": "practice.PsychometricTest.solution",
        "description": "practice.PsychometricTest.solution",
        "peekOfCode": "def findUpper(scores, len_score, v):\n    l = 0\n    u = len_score - 1\n    while l <= u:\n        mid = (l + u) // 2\n        if scores[mid] > v:\n            u = mid - 1\n        else:\n            l = mid + 1\n    return u",
        "detail": "practice.PsychometricTest.solution",
        "documentation": {}
    },
    {
        "label": "jobOffers",
        "kind": 2,
        "importPath": "practice.PsychometricTest.solution",
        "description": "practice.PsychometricTest.solution",
        "peekOfCode": "def jobOffers(scores, lowerLimits, upperLimits):\n    scores.sort()\n    n = len(scores)\n    for index in range(len(lowerLimits)):\n        yield findUpper(scores, n, upperLimits[index]) - findLower(\n            scores, n, lowerLimits[index]\n        ) + 1\nfor i in jobOffers([1, 2, 2, 3, 5, 6, 7], [1], [7]):\n    print(i)",
        "detail": "practice.PsychometricTest.solution",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "practice.PYTHON.01 - add",
        "description": "practice.PYTHON.01 - add",
        "peekOfCode": "def add(param1, param2):\n    # A pretty straightforward exercise. A function including 2 parameters, which are summed together, returning the sum as the result.\n    sum = param1 + param2\n    return sum",
        "detail": "practice.PYTHON.01 - add",
        "documentation": {}
    },
    {
        "label": "centuryFromYear",
        "kind": 2,
        "importPath": "practice.PYTHON.02 - centuryFromYear",
        "description": "practice.PYTHON.02 - centuryFromYear",
        "peekOfCode": "def centuryFromYear(year):\n    # We begin by getting the INTEGER quotient of the division of the year given by 100.\n    # This will give us the first two digits, which would be the century.\n    cen = int(year / 100)\n    # However, we should keep in mind that we refer to years between e.g. 1701 - 1800\n    # as the \"18th century\". Hence, we implement a while loop, where the condition is\n    # that the year is a positive integer (which is always true). If the remainder of the\n    # division of the year by 100 is 0, then the two first digits of the division represent\n    # the century. Otherwise, if the remainder is non-zero, the century is found by adding 1\n    # to the result of the division (i.e. \"cen\").",
        "detail": "practice.PYTHON.02 - centuryFromYear",
        "documentation": {}
    },
    {
        "label": "checkPalindrome",
        "kind": 2,
        "importPath": "practice.PYTHON.03 - checkPalindrome",
        "description": "practice.PYTHON.03 - checkPalindrome",
        "peekOfCode": "def checkPalindrome(inputString):\n    # Step 1: We turn all letters in our given string into lower case.\n    inp = inputString.lower()\n    # Step 2: Also, we discard all space between words or letters.\n    # It is important to store the result in the same variable as in step 1.\n    # Think of it as only dealing with discarding the spaces.\n    inp = inp.replace(\" \", \"\")\n    # The first two steps help us end up with a long, uniform (in terms of letter size) string.\n    # Step 3: We define a variable called \"reverse\" as the reversed counterpart of the input string.\n    reverse = inp[::-1]",
        "detail": "practice.PYTHON.03 - checkPalindrome",
        "documentation": {}
    },
    {
        "label": "adjacentElementsProduct",
        "kind": 2,
        "importPath": "practice.PYTHON.04 - adjacentElementsProduct",
        "description": "practice.PYTHON.04 - adjacentElementsProduct",
        "peekOfCode": "def adjacentElementsProduct(inputArray):\n    # Step 1: Initially, define an empty array where we will store the products of adjacent elements from the input array.\n    ArrayEnd = []\n    # Step 2: Using a for-loop, we go over all entries of the input array, calculating the products of adjacent elements\n    # and appending them to the empty array from step 1.\n    for i in range(len(inputArray) - 1):\n        ArrayEnd.append(inputArray[i] * inputArray[i + 1])\n    # Step 3: We seek the largest entry in \"ArrayEnd\" from step 1, using the max() function.\n    maximum = max(ArrayEnd)\n    return maximum",
        "detail": "practice.PYTHON.04 - adjacentElementsProduct",
        "documentation": {}
    },
    {
        "label": "shapeArea",
        "kind": 2,
        "importPath": "practice.PYTHON.05 - shapeArea",
        "description": "practice.PYTHON.05 - shapeArea",
        "peekOfCode": "def shapeArea(n):\n    # Case 1: If the polygon is 0-interesting, it has an area equal to zero.\n    if n == 0:\n        return None\n    # Case 2: If the polygon is 1-interesting, it has an area equal to one.\n    elif n == 1:\n        return 1\n    # Case 3: If the polygon is n-interesting, it has an area equal to the sum of the square of n\n    # and the square of n-1. A way that I thought of it (based on the picture provided) is the following:\n    # - n**2: Counted the number of the blue squares from the middle line upwards (INCLUDING the blue squares of the middle line).",
        "detail": "practice.PYTHON.05 - shapeArea",
        "documentation": {}
    },
    {
        "label": "makeArrayConsecutive2",
        "kind": 2,
        "importPath": "practice.PYTHON.06 - makeArrayConsecutive2",
        "description": "practice.PYTHON.06 - makeArrayConsecutive2",
        "peekOfCode": "def makeArrayConsecutive2(statues):\n    # Step 1: We begin by creating a new array called \"stat_arr\", which will accommodate the sorted version of the original \"statues\" array.\n    stat_arr = sorted(statues)\n    # Step 2: Furthermore, we use the first element of the sorted array as our index (that will be used in the following steps).\n    i = stat_arr[0]\n    # Step 3: We create an empty list called \"result\" to store our (numbered) missing statues.\n    result = list()\n    # Step 4: We initiate a while-loop with the condition that the index from Step 2 is not equal to the last (hence largest) entry of\n    # the stat_arr. You must make sure that you add the \"incrementation by 1\" part to make the while loop proceed to the next element.\n    while i != stat_arr[-1]:",
        "detail": "practice.PYTHON.06 - makeArrayConsecutive2",
        "documentation": {}
    },
    {
        "label": "almostIncreasingSequence",
        "kind": 2,
        "importPath": "practice.PYTHON.07 - almostIncreasingSequence",
        "description": "practice.PYTHON.07 - almostIncreasingSequence",
        "peekOfCode": "def almostIncreasingSequence(sequence):\n    # Step 1: We begin by assigning the length of the given sequence to the variable n.\n    n = len(sequence)\n    # Step 2: By definition, if the sequence contains up to 1 elements, it is considered to be strictly increasing.\n    if n <= 2:\n        return True\n    # Step 3: We set up two counters, namely c1 and c2, so that we count how many elements should be removed.\n    # NOTE THAT c1 refers ONLY to adjacent elements whilst c2 refers to elements just before and just after the i-th element.\n    c1 = 0\n    c2 = 0",
        "detail": "practice.PYTHON.07 - almostIncreasingSequence",
        "documentation": {}
    },
    {
        "label": "matrixElementsSum",
        "kind": 2,
        "importPath": "practice.PYTHON.08 - matrixElementsSum",
        "description": "practice.PYTHON.08 - matrixElementsSum",
        "peekOfCode": "def matrixElementsSum(matrix):\n    # Step 1: We begin by defining the number of rows and columns inside our given matrix.\n    # You can conceive the number of rows as the number of nested arrays inside the main array and\n    # the number of columns as the number of elements in the first nested array.\n    # Feel free to convince yourself that this is the case by referring to the examples of matrices shown above.\n    rows = len(matrix)\n    cols = len(matrix[0])\n    # Step 2: Furthermore, create a new variable called \"summ\" (from summation) and set it equal to zero.\n    # It will be used in the following for-loop.\n    summ = 0",
        "detail": "practice.PYTHON.08 - matrixElementsSum",
        "documentation": {}
    },
    {
        "label": "matrix",
        "kind": 5,
        "importPath": "practice.PYTHON.08 - matrixElementsSum",
        "description": "practice.PYTHON.08 - matrixElementsSum",
        "peekOfCode": "matrix = [[0, 1, 1, 2],\n          [0, 5, 0, 0],\n          [2, 0, 3, 3]]\nthe output should be matrixElementsSum(matrix) = 9.\nexample 1: There are several haunted rooms, so we'll disregard them as well as any rooms beneath them.\nThus, the answer is 1 + 5 + 1 + 2 = 9. (PICTURE PROVIDED AT:WWW.CODESIGNAL.COM)\nFor\nmatrix = [[1, 1, 1, 0],\n          [0, 5, 0, 1],\n          [2, 1, 3, 10]]",
        "detail": "practice.PYTHON.08 - matrixElementsSum",
        "documentation": {}
    },
    {
        "label": "matrix",
        "kind": 5,
        "importPath": "practice.PYTHON.08 - matrixElementsSum",
        "description": "practice.PYTHON.08 - matrixElementsSum",
        "peekOfCode": "matrix = [[1, 1, 1, 0],\n          [0, 5, 0, 1],\n          [2, 1, 3, 10]]\nthe output should be matrixElementsSum(matrix) = 9.\nexample 2:\nNote that the free room in the final column makes the full column unsuitable for bots (not just the room directly beneath it).\nThus, the answer is 1 + 1 + 1 + 5 + 1 = 9. (PICTURE PROVIDED AT:WWW.CODESIGNAL.COM)\"\"\"\ndef matrixElementsSum(matrix):\n    # Step 1: We begin by defining the number of rows and columns inside our given matrix.\n    # You can conceive the number of rows as the number of nested arrays inside the main array and",
        "detail": "practice.PYTHON.08 - matrixElementsSum",
        "documentation": {}
    },
    {
        "label": "allLongestStrings",
        "kind": 2,
        "importPath": "practice.PYTHON.09 - allLongestStrings",
        "description": "practice.PYTHON.09 - allLongestStrings",
        "peekOfCode": "def allLongestStrings(inputArray):\n    # Step 1: We begin by defining an empty array called \"max_arr\", where we will store the longest strings from the given array.\n    max_arr = []\n    # Step 2: The next step is to define the maximum string length inside our given array.\n    # BE CAREFUL: Variable max_len should be defined as follows. If we break it into its components, we can see that:\n    # max(inputArray, key = len) locates ONLY ONE of the strings that satisfies the maximum value in terms of the key parameter\n    # provided (which, in this case, is the string's length) and the outside len() function defines the value of this maximum length.\n    # You are free to test it on a random input array containing various random strings, using a Python compiler online.\n    max_len = len(max(inputArray, key=len))\n    # Step 3: Now, we go over all strings inside the input array checking if their individual length is equal to the",
        "detail": "practice.PYTHON.09 - allLongestStrings",
        "documentation": {}
    },
    {
        "label": "commonCharacterCount",
        "kind": 2,
        "importPath": "practice.PYTHON.10 - commonCharacterCount",
        "description": "practice.PYTHON.10 - commonCharacterCount",
        "peekOfCode": "def commonCharacterCount(s1, s2):\n    # Step 1: We create two lists, namely s1_l and s2_l, where we store the characters of strings s1 and s2 respectively.\n    s1_l = list(s1)\n    s2_l = list(s2)\n    # Step 2: We also create an empty list, where we are going to store all common characters.\n    common = []\n    # Step 3: Using a for-loop, we investigate the list of the first string, element by element.\n    for i in s1_l:\n        # Step 4: If the i-th element from the list of the first string is also present in the list of the second string,\n        # we append it to the common array. BE CAREFUL: We must implement the s2_l.remove(i) to avoid double-counting.",
        "detail": "practice.PYTHON.10 - commonCharacterCount",
        "documentation": {}
    },
    {
        "label": "isLucky",
        "kind": 2,
        "importPath": "practice.PYTHON.11 - isLucky",
        "description": "practice.PYTHON.11 - isLucky",
        "peekOfCode": "def isLucky(n):\n    # Step 1: We begin by creating an empty array, called \"digits_of_n\",\n    # where we will store the digits of the given number n, as individual elements.\n    digits_of_n = []\n    # Step 2: We also create a new variable, called \"summ\" (from summation), and set its value to zero.\n    # It will be useful in one of the later steps.\n    summ = 0\n    # Step 3: I have personally seen this while-loop trick being used to split numbers into their individual digits.\n    # As it will take quite a long text to explain this comprehensively, I'd suggest you use the print() function in each\n    # step to see what how each of these steps works. The important thing to mention is the \"appending\" step where each",
        "detail": "practice.PYTHON.11 - isLucky",
        "documentation": {}
    },
    {
        "label": "sortByHeight",
        "kind": 2,
        "importPath": "practice.PYTHON.12 - sortByHeight",
        "description": "practice.PYTHON.12 - sortByHeight",
        "peekOfCode": "def sortByHeight(a):\n    # Step 1: We begin by creating a counter, starting from 0, that will be used in the subsequent for-loop.\n    j = 0\n    # Step 2: We also create a new array, called \"a_sort\", where we sort (in ascending order) all elements of the given array \"a\"\n    # that are not \"trees\" (i.e. do not have a value of -1).\n    a_sort = sorted([i for i in a if i != -1])\n    # Step 3: By implementing a for-loop, we investigate all elements of the given array \"a\" (NOT a_sort!) and check:\n    # if the element i in array \"a\" is equal to -1, the for-loop continues. Otherwise, the element i in array \"a\" should be\n    # the same as element j in array \"a_sort\" (starting from 0 index, as defined in step 1).\n    # You can think of it as working through elements of array \"a\", disregarding the \"trees\" (-1s) and sorting the rest",
        "detail": "practice.PYTHON.12 - sortByHeight",
        "documentation": {}
    },
    {
        "label": "reverseInParentheses",
        "kind": 2,
        "importPath": "practice.PYTHON.13 - reverseInParentheses",
        "description": "practice.PYTHON.13 - reverseInParentheses",
        "peekOfCode": "def reverseInParentheses(inputString):\n    # Step 1: We create a for-loop that goes over all elements of the input string. If element i is an opening bracket, then i\n    # is defined as \"start\". In a similar manner, if element i is a closing bracket, i is defined as \"end\". NOTE THAT\n    # if you write it as \"i = start\" or \"i = end\", an error will pop up (tested) as you would have not defined any variables\n    # under those names, whilst the way that is written now you define as \"start\" and \"end\" elements that are\n    # \"(\" and \")\" respectively.\n    for i in range(len(inputString)):\n        if inputString[i] == \"(\":\n            start = i\n        if inputString[i] == \")\":",
        "detail": "practice.PYTHON.13 - reverseInParentheses",
        "documentation": {}
    },
    {
        "label": "alternatingSums",
        "kind": 2,
        "importPath": "practice.PYTHON.14 - alternatingSums",
        "description": "practice.PYTHON.14 - alternatingSums",
        "peekOfCode": "def alternatingSums(a):\n    # Step 1: We begin by creating an array, called \"alt_sum\", that includes only two elements of value 0.\n    alt_sum = [0, 0]\n    # Step 2: Moreover, we define the variable \"length\", which is the numerical value of the length of input array a.\n    length = len(a)\n    # Step 3: Starting from the first element of input array \"a\" and working all the way through its length,\n    # we check whether the element's index is even or odd. If the element i is even, we add its value to the\n    # first element of the \"alt_sum\" array, whilst if it is odd we add it to the second element.\n    for i in range(0, length):\n        if i % 2 == 0:",
        "detail": "practice.PYTHON.14 - alternatingSums",
        "documentation": {}
    },
    {
        "label": "addBorder",
        "kind": 2,
        "importPath": "practice.PYTHON.15 - addBorder",
        "description": "practice.PYTHON.15 - addBorder",
        "peekOfCode": "def addBorder(picture):\n    new_pic = []\n    border = \"\"\n    pic_len = len(picture)\n    for i in range(0, len(picture[0]) + 2):\n        border += \"*\"\n    new_pic.append(border)\n    for i in range(0, pic_len):\n        new_pic.append(\"*\" + picture[i] + \"*\")\n    new_pic.append(border)",
        "detail": "practice.PYTHON.15 - addBorder",
        "documentation": {}
    },
    {
        "label": "areSimilar",
        "kind": 2,
        "importPath": "practice.PYTHON.16 - areSimilar",
        "description": "practice.PYTHON.16 - areSimilar",
        "peekOfCode": "def areSimilar(a, b):\n    check_a = []\n    check_b = []\n    count = 0\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            count += 1\n            check_a.append(a[i])\n            check_b.append(b[i])\n    if count == 0:",
        "detail": "practice.PYTHON.16 - areSimilar",
        "documentation": {}
    },
    {
        "label": "arrayChange",
        "kind": 2,
        "importPath": "practice.PYTHON.17 - arrayChange",
        "description": "practice.PYTHON.17 - arrayChange",
        "peekOfCode": "def arrayChange(inputArray):\n    first = inputArray[0]\n    count = 0\n    for i in inputArray[1:]:\n        if i <= first:\n            count += first - i + 1\n            first = first + 1\n        else:\n            first = i\n    return count",
        "detail": "practice.PYTHON.17 - arrayChange",
        "documentation": {}
    },
    {
        "label": "palindromeRearranging",
        "kind": 2,
        "importPath": "practice.PYTHON.18 - palindromeRearranging",
        "description": "practice.PYTHON.18 - palindromeRearranging",
        "peekOfCode": "def palindromeRearranging(inputString):\n    odd_count = 0\n    char_set = set(inputString)\n    for i in char_set:\n        char_count = inputString.count(i)\n        if char_count % 2 != 0:\n            odd_count += 1\n    if odd_count <= 1:\n        return True\n    return False",
        "detail": "practice.PYTHON.18 - palindromeRearranging",
        "documentation": {}
    },
    {
        "label": "areEquallyStrong",
        "kind": 2,
        "importPath": "practice.PYTHON.19 - areEquallyStrong",
        "description": "practice.PYTHON.19 - areEquallyStrong",
        "peekOfCode": "def areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight):\n    personal_max = max(yourLeft, yourRight)\n    friend_max = max(friendsLeft, friendsRight)\n    sum1 = yourLeft + yourRight\n    sum2 = friendsLeft + friendsRight\n    if sum1 == sum2 and personal_max == friend_max:\n        return True\n    return False",
        "detail": "practice.PYTHON.19 - areEquallyStrong",
        "documentation": {}
    },
    {
        "label": "arrayMaximalAdjacentDifference",
        "kind": 2,
        "importPath": "practice.PYTHON.20 - arrayMaximalAdjacentDifference",
        "description": "practice.PYTHON.20 - arrayMaximalAdjacentDifference",
        "peekOfCode": "def arrayMaximalAdjacentDifference(inputArray):\n    return max(\n        (abs(inputArray[i + 1] - inputArray[i]) for i in range(0, len(inputArray) - 1))\n    )",
        "detail": "practice.PYTHON.20 - arrayMaximalAdjacentDifference",
        "documentation": {}
    },
    {
        "label": "isIPv4Address",
        "kind": 2,
        "importPath": "practice.PYTHON.21 - isIPv4Address",
        "description": "practice.PYTHON.21 - isIPv4Address",
        "peekOfCode": "def isIPv4Address(inputString):\n    str_split = inputString.split(\".\")\n    count = 0\n    if len(str_split) != 4:\n        return False\n    for i in range(0, 4):\n        if str_split[i] == \"\" or str_split[i] == \"00\" or str_split[i] == \"01\":\n            return False\n        if re.search(\"[a-zA-Z]\", str_split[i]):\n            count += 1",
        "detail": "practice.PYTHON.21 - isIPv4Address",
        "documentation": {}
    },
    {
        "label": "avoidObstacles",
        "kind": 2,
        "importPath": "practice.PYTHON.22 - avoidObstacles",
        "description": "practice.PYTHON.22 - avoidObstacles",
        "peekOfCode": "def avoidObstacles(inputArray):\n    for i in range(2, max(inputArray) + 2):\n        if i not in inputArray and all(j % i != 0 for j in inputArray):\n            return i",
        "detail": "practice.PYTHON.22 - avoidObstacles",
        "documentation": {}
    },
    {
        "label": "boxBlur",
        "kind": 2,
        "importPath": "practice.PYTHON.23 - boxBlur",
        "description": "practice.PYTHON.23 - boxBlur",
        "peekOfCode": "def boxBlur(image):\n    def pixels(matrix, i, j):\n        summ = 0\n        for x in range(i - 1, i + 2):\n            for y in range(j - 1, j + 2):\n                summ += matrix[x][y]\n                mean = summ // 9\n        return mean\n    output = []\n    row = len(image)",
        "detail": "practice.PYTHON.23 - boxBlur",
        "documentation": {}
    },
    {
        "label": "minesweeper",
        "kind": 2,
        "importPath": "practice.PYTHON.24 - minesweeper",
        "description": "practice.PYTHON.24 - minesweeper",
        "peekOfCode": "def minesweeper(matrix):\n    row = len(matrix)\n    col = len(matrix[0])\n    def neighbouring_squares(i, j):\n        return sum(\n            matrix[x][y]\n            for x in range(i - 1, i + 2)\n            if 0 <= x < row\n            for y in range(j - 1, j + 2)\n            if 0 <= y < col",
        "detail": "practice.PYTHON.24 - minesweeper",
        "documentation": {}
    },
    {
        "label": "arrayReplace",
        "kind": 2,
        "importPath": "practice.PYTHON.25 - arrayReplace",
        "description": "practice.PYTHON.25 - arrayReplace",
        "peekOfCode": "def arrayReplace(inputArray, elemToReplace, substitutionElem):\n    new = []\n    for i in range(len(inputArray)):\n        if inputArray[i] == elemToReplace:\n            new.append(substitutionElem)\n        else:\n            new.append(inputArray[i])\n    return new",
        "detail": "practice.PYTHON.25 - arrayReplace",
        "documentation": {}
    },
    {
        "label": "evenDigitsOnly",
        "kind": 2,
        "importPath": "practice.PYTHON.26 - evenDigitsOnly",
        "description": "practice.PYTHON.26 - evenDigitsOnly",
        "peekOfCode": "def evenDigitsOnly(n):\n    digits_of_n = []\n    while n > 0:\n        rem = n % 10\n        digits_of_n.append(rem)\n        n = int(n / 10)\n    for i in range(len(digits_of_n)):\n        if digits_of_n[i] % 2 != 0:\n            return False\n    return True",
        "detail": "practice.PYTHON.26 - evenDigitsOnly",
        "documentation": {}
    },
    {
        "label": "variableName",
        "kind": 2,
        "importPath": "practice.PYTHON.27 - variableName",
        "description": "practice.PYTHON.27 - variableName",
        "peekOfCode": "def variableName(name):\n    str_name = [i for i in str(name)]\n    non_acc_chars = [\n        \" \",\n        \">\",\n        \"<\",\n        \":\",\n        \"-\",\n        \"|\",\n        \".\",",
        "detail": "practice.PYTHON.27 - variableName",
        "documentation": {}
    },
    {
        "label": "alphabeticShift",
        "kind": 2,
        "importPath": "practice.PYTHON.28 - alphabeticShift",
        "description": "practice.PYTHON.28 - alphabeticShift",
        "peekOfCode": "def alphabeticShift(inputString):\n    return \"\".join(chr(ord(i) + 1) if i != \"z\" else \"a\" for i in inputString)",
        "detail": "practice.PYTHON.28 - alphabeticShift",
        "documentation": {}
    },
    {
        "label": "chessBoardCellColor",
        "kind": 2,
        "importPath": "practice.PYTHON.29 - chessBoardCellColor",
        "description": "practice.PYTHON.29 - chessBoardCellColor",
        "peekOfCode": "def chessBoardCellColor(cell1, cell2):\n    cell1_elm = ord(cell1[0]) + int(cell1[1])\n    cell2_elm = ord(cell2[0]) + int(cell2[1])\n    return (cell1_elm + cell2_elm) % 2 == 0",
        "detail": "practice.PYTHON.29 - chessBoardCellColor",
        "documentation": {}
    },
    {
        "label": "circleOfNumbers",
        "kind": 2,
        "importPath": "practice.PYTHON.30 - circleOfNumbers",
        "description": "practice.PYTHON.30 - circleOfNumbers",
        "peekOfCode": "def circleOfNumbers(n, firstNumber):\n    return ((n / 2) + firstNumber) % n",
        "detail": "practice.PYTHON.30 - circleOfNumbers",
        "documentation": {}
    },
    {
        "label": "depositProfit",
        "kind": 2,
        "importPath": "practice.PYTHON.31 - depositProfit",
        "description": "practice.PYTHON.31 - depositProfit",
        "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    year_count = 0\n    while deposit < threshold:\n        deposit = deposit + (deposit * (rate / 100))\n        year_count += 1\n    return year_count",
        "detail": "practice.PYTHON.31 - depositProfit",
        "documentation": {}
    },
    {
        "label": "absoluteValuesSumMinimization",
        "kind": 2,
        "importPath": "practice.PYTHON.32 - absoluteValuesSumMinimization",
        "description": "practice.PYTHON.32 - absoluteValuesSumMinimization",
        "peekOfCode": "def absoluteValuesSumMinimization(a):\n    sums = []\n    for i in range(len(a)):\n        sum = 0\n        for j in range(len(a)):\n            sum += abs(a[i] - a[j])\n        sums.append(sum)\n    return a[sums.index(min(sums))]",
        "detail": "practice.PYTHON.32 - absoluteValuesSumMinimization",
        "documentation": {}
    },
    {
        "label": "stringsRearrangement",
        "kind": 2,
        "importPath": "practice.PYTHON.33 - stringsRearrangement",
        "description": "practice.PYTHON.33 - stringsRearrangement",
        "peekOfCode": "def stringsRearrangement(inputArray):\n    p_list = list(p(inputArray))\n    for i in range(len(p_list)):\n        count1 = 0\n        for j in range(len(p_list[0]) - 1):\n            count2 = 0\n            for k in range(len(p_list[0][0])):\n                if p_list[i][j][k] != p_list[i][j + 1][k]:\n                    count2 += 1\n            if count2 == 1:",
        "detail": "practice.PYTHON.33 - stringsRearrangement",
        "documentation": {}
    },
    {
        "label": "extractEachKth",
        "kind": 2,
        "importPath": "practice.PYTHON.34 - extractEachKth",
        "description": "practice.PYTHON.34 - extractEachKth",
        "peekOfCode": "def extractEachKth(inputArray, k):\n    inp = []\n    for i in range(len(inputArray)):\n        if (i + 1) % k == 0:\n            pass\n        else:\n            inp.append(inputArray[i])\n    return inp",
        "detail": "practice.PYTHON.34 - extractEachKth",
        "documentation": {}
    },
    {
        "label": "firstDigit",
        "kind": 2,
        "importPath": "practice.PYTHON.35 - firstDigit",
        "description": "practice.PYTHON.35 - firstDigit",
        "peekOfCode": "def firstDigit(inputString):\n    c = [i for i in inputString if i.isdigit()]\n    return c[0]",
        "detail": "practice.PYTHON.35 - firstDigit",
        "documentation": {}
    },
    {
        "label": "differentSymbolsNaive",
        "kind": 2,
        "importPath": "practice.PYTHON.36 - differentSymbolsNaive",
        "description": "practice.PYTHON.36 - differentSymbolsNaive",
        "peekOfCode": "def differentSymbolsNaive(s):\n    return len(set(s))",
        "detail": "practice.PYTHON.36 - differentSymbolsNaive",
        "documentation": {}
    },
    {
        "label": "arrayMaxConsecutiveSum",
        "kind": 2,
        "importPath": "practice.PYTHON.37 - arrayMaxConsecutiveSum",
        "description": "practice.PYTHON.37 - arrayMaxConsecutiveSum",
        "peekOfCode": "def arrayMaxConsecutiveSum(inputArray, k):\n    arr = [sum(inputArray[:k])]\n    for i in range(1, len(inputArray) - (k - 1)):\n        arr.append(arr[i - 1] - inputArray[i - 1] + inputArray[i + k - 1])\n    sort_arr = sorted(arr)\n    return sort_arr[-1]",
        "detail": "practice.PYTHON.37 - arrayMaxConsecutiveSum",
        "documentation": {}
    },
    {
        "label": "growingPlant",
        "kind": 2,
        "importPath": "practice.PYTHON.38 - growingPlant",
        "description": "practice.PYTHON.38 - growingPlant",
        "peekOfCode": "def growingPlant(upSpeed, downSpeed, desiredHeight):\n    day_count = 0\n    height = 0\n    while height <= desiredHeight:\n        height = height + upSpeed\n        day_count += 1\n        if height < desiredHeight:\n            height = height - downSpeed\n        else:\n            return day_count",
        "detail": "practice.PYTHON.38 - growingPlant",
        "documentation": {}
    },
    {
        "label": "knapsackLight",
        "kind": 2,
        "importPath": "practice.PYTHON.39 - knapsackLight",
        "description": "practice.PYTHON.39 - knapsackLight",
        "peekOfCode": "def knapsackLight(value1, weight1, value2, weight2, maxW):\n    if weight1 > maxW and weight2 > maxW and weight1 + weight2 > maxW:\n        return 0\n    if weight1 + weight2 <= maxW:\n        return value1 + value2\n    if value1 < value2:\n        if weight2 > maxW:\n            return value1\n        else:\n            return value2",
        "detail": "practice.PYTHON.39 - knapsackLight",
        "documentation": {}
    },
    {
        "label": "longestDigitsPrefix",
        "kind": 2,
        "importPath": "practice.PYTHON.40 - longestDigitsPrefix",
        "description": "practice.PYTHON.40 - longestDigitsPrefix",
        "peekOfCode": "def longestDigitsPrefix(inputString):\n    count = 0\n    for i in range(len(inputString)):\n        if inputString[i].isdigit():\n            count += 1\n        else:\n            return inputString[0:count]\n    return inputString",
        "detail": "practice.PYTHON.40 - longestDigitsPrefix",
        "documentation": {}
    },
    {
        "label": "digitDegree",
        "kind": 2,
        "importPath": "practice.PYTHON.41 - digitDegree",
        "description": "practice.PYTHON.41 - digitDegree",
        "peekOfCode": "def digitDegree(n):\n    degree = 0\n    while 10 <= n:\n        num = str(n)\n        n = sum(int(i) for i in num)\n        degree += 1\n    return degree",
        "detail": "practice.PYTHON.41 - digitDegree",
        "documentation": {}
    },
    {
        "label": "bishopAndPawn",
        "kind": 2,
        "importPath": "practice.PYTHON.42 - bishopAndPawn",
        "description": "practice.PYTHON.42 - bishopAndPawn",
        "peekOfCode": "def bishopAndPawn(bishop, pawn):\n    if ord(bishop[0]) == ord(pawn[0]):\n        return False\n    else:\n        bishop_elm = ord(bishop[0]) + int(bishop[1])\n        pawn_elm = ord(pawn[0]) + int(pawn[1])\n        return (bishop_elm + pawn_elm) % 2 == 0",
        "detail": "practice.PYTHON.42 - bishopAndPawn",
        "documentation": {}
    },
    {
        "label": "isBeautifulString",
        "kind": 2,
        "importPath": "practice.PYTHON.43 - isBeautifulString",
        "description": "practice.PYTHON.43 - isBeautifulString",
        "peekOfCode": "def isBeautifulString(inputString):\n    counter = [inputString.count(i) for i in string.ascii_lowercase]\n    return counter[::-1] == sorted(counter)",
        "detail": "practice.PYTHON.43 - isBeautifulString",
        "documentation": {}
    },
    {
        "label": "findEmailDomain",
        "kind": 2,
        "importPath": "practice.PYTHON.44 - findEmailDomain",
        "description": "practice.PYTHON.44 - findEmailDomain",
        "peekOfCode": "def findEmailDomain(address):\n    address_spl = address.split(\"@\")\n    c = [i for i in address_spl]\n    if len(address_spl) == 2:\n        return c[1]\n    if len(address_spl) == 3:\n        return c[2]",
        "detail": "practice.PYTHON.44 - findEmailDomain",
        "documentation": {}
    },
    {
        "label": "buildPalindrome",
        "kind": 2,
        "importPath": "practice.PYTHON.45 - buildPalindrome",
        "description": "practice.PYTHON.45 - buildPalindrome",
        "peekOfCode": "def buildPalindrome(st):\n    for i in range(len(st)):\n        sub = st[i : len(st)]\n        if sub[::-1] == sub:\n            missing = st[0:i]\n            return st + missing[::-1]\n    return st",
        "detail": "practice.PYTHON.45 - buildPalindrome",
        "documentation": {}
    },
    {
        "label": "electionsWinners",
        "kind": 2,
        "importPath": "practice.PYTHON.46 - electionWinners",
        "description": "practice.PYTHON.46 - electionWinners",
        "peekOfCode": "def electionsWinners(votes, k):\n    max_vote = max(votes)\n    len_vote = len(votes)\n    if k == 0 and votes.count(max_vote) == 1:\n        return 1\n    return len([i for i in range(len_vote) if votes[i] + k > max_vote])",
        "detail": "practice.PYTHON.46 - electionWinners",
        "documentation": {}
    },
    {
        "label": "isMAC48Address",
        "kind": 2,
        "importPath": "practice.PYTHON.47 - isMAC48Address",
        "description": "practice.PYTHON.47 - isMAC48Address",
        "peekOfCode": "def isMAC48Address(inputString):\n    str_split = inputString.split(\"-\")\n    count = 0\n    if len(inputString) != 17:\n        return False\n    if len(str_split) != 6:\n        return False\n    for i in range(0, 6):\n        if str_split[i] == \"\":\n            return False",
        "detail": "practice.PYTHON.47 - isMAC48Address",
        "documentation": {}
    },
    {
        "label": "isDigit",
        "kind": 2,
        "importPath": "practice.PYTHON.48 - isDigit",
        "description": "practice.PYTHON.48 - isDigit",
        "peekOfCode": "def isDigit(symbol):\n    if symbol.isdigit():\n        return True\n    return False\n# Solution 2: One-liner\ndef isDigit(symbol):\n    return symbol.isdigit()",
        "detail": "practice.PYTHON.48 - isDigit",
        "documentation": {}
    },
    {
        "label": "isDigit",
        "kind": 2,
        "importPath": "practice.PYTHON.48 - isDigit",
        "description": "practice.PYTHON.48 - isDigit",
        "peekOfCode": "def isDigit(symbol):\n    return symbol.isdigit()",
        "detail": "practice.PYTHON.48 - isDigit",
        "documentation": {}
    },
    {
        "label": "lineEncoding",
        "kind": 2,
        "importPath": "practice.PYTHON.49 - lineEncoding",
        "description": "practice.PYTHON.49 - lineEncoding",
        "peekOfCode": "def lineEncoding(s):\n    s2 = \"\"\n    for k, g in groupby(s):\n        l = len(list(g))\n        if l == 1:\n            s2 += k\n        else:\n            s2 += str(l) + k\n    return s2",
        "detail": "practice.PYTHON.49 - lineEncoding",
        "documentation": {}
    },
    {
        "label": "chessKnight",
        "kind": 2,
        "importPath": "practice.PYTHON.50 - chessKnight",
        "description": "practice.PYTHON.50 - chessKnight",
        "peekOfCode": "def chessKnight(cell):\n    knight_dir = list(t.permutations([1, 2, -1, -2], 2))\n    knight_dir1 = []\n    valid_moves = 0\n    for i in range(len(knight_dir)):\n        if sum(knight_dir[i]) != 0:\n            knight_dir1.append(knight_dir[i])\n    for x, y in knight_dir1:\n        if (97 <= ord(cell[0]) + x <= 104) and (1 <= int(cell[1]) + y <= 8):\n            valid_moves += 1",
        "detail": "practice.PYTHON.50 - chessKnight",
        "documentation": {}
    },
    {
        "label": "deleteDigit",
        "kind": 2,
        "importPath": "practice.PYTHON.51 - deleteDigit",
        "description": "practice.PYTHON.51 - deleteDigit",
        "peekOfCode": "def deleteDigit(n):\n    num = str(n)\n    result = list(int(\"\".join(num[:i] + num[1 + i :])) for i in range(len(num)))\n    return max(result)",
        "detail": "practice.PYTHON.51 - deleteDigit",
        "documentation": {}
    },
    {
        "label": "longestWord",
        "kind": 2,
        "importPath": "practice.PYTHON.52 - longestWord",
        "description": "practice.PYTHON.52 - longestWord",
        "peekOfCode": "def longestWord(text):\n    word_split = re.findall(r\"[\\w']+\", text)\n    longest_word = \"\"\n    for word in word_split:\n        if len(word) > len(longest_word) and word.isalpha():\n            longest_word = word\n    return longest_word",
        "detail": "practice.PYTHON.52 - longestWord",
        "documentation": {}
    },
    {
        "label": "validTime",
        "kind": 2,
        "importPath": "practice.PYTHON.53 - validTime",
        "description": "practice.PYTHON.53 - validTime",
        "peekOfCode": "def validTime(time):\n    time_split = time.split(\":\")\n    if 00 <= int(time_split[0]) <= 23 and 00 <= int(time_split[1]) <= 59:\n        return True\n    return False",
        "detail": "practice.PYTHON.53 - validTime",
        "documentation": {}
    },
    {
        "label": "sumUpNumbers",
        "kind": 2,
        "importPath": "practice.PYTHON.54 - sumUpNumbers",
        "description": "practice.PYTHON.54 - sumUpNumbers",
        "peekOfCode": "def sumUpNumbers(inputString):\n    def getNumbers(str):\n        nums = re.findall(r\"[0-9]+\", str)\n        return nums\n    numbers = getNumbers(inputString)\n    total = 0\n    for i in numbers:\n        total += int(i)\n    return total",
        "detail": "practice.PYTHON.54 - sumUpNumbers",
        "documentation": {}
    },
    {
        "label": "differentSquares",
        "kind": 2,
        "importPath": "practice.PYTHON.55 - differentSquares",
        "description": "practice.PYTHON.55 - differentSquares",
        "peekOfCode": "def differentSquares(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    sq_arr = []\n    sq_count = 0\n    for i in range(rows - 1):\n        for j in range(cols - 1):\n            sq_2x2 = [\n                matrix[i][j],\n                matrix[i][j + 1],",
        "detail": "practice.PYTHON.55 - differentSquares",
        "documentation": {}
    },
    {
        "label": "digitsProduct",
        "kind": 2,
        "importPath": "practice.PYTHON.56 - digitsProduct",
        "description": "practice.PYTHON.56 - digitsProduct",
        "peekOfCode": "def digitsProduct(product):\n    if product == 0:\n        return 10\n    if product == 1:\n        return 1\n    for i in range(0, 4000):\n        p = 1\n        for j in str(i):\n            p *= int(j)\n        if p == product:",
        "detail": "practice.PYTHON.56 - digitsProduct",
        "documentation": {}
    },
    {
        "label": "fileNaming",
        "kind": 2,
        "importPath": "practice.PYTHON.57 - fileNaming",
        "description": "practice.PYTHON.57 - fileNaming",
        "peekOfCode": "def fileNaming(names):\n    if names == []:\n        return []\n    new_names = []\n    for name in names:\n        if name not in new_names:\n            new_names.append(name)\n        else:\n            for i in range(1, 1000):\n                new_name = name + \"(\" + str(i) + \")\"",
        "detail": "practice.PYTHON.57 - fileNaming",
        "documentation": {}
    },
    {
        "label": "messageFromBinaryCode",
        "kind": 2,
        "importPath": "practice.PYTHON.58 - messageFromBinaryCode",
        "description": "practice.PYTHON.58 - messageFromBinaryCode",
        "peekOfCode": "def messageFromBinaryCode(code):\n    phrase = \"\"\n    bits = [int(code[i * 8 : i * 8 + 8], 2) for i in range(len(code) // 8)]\n    for j in range(len(bits)):\n        phrase += chr(bits[j])\n    return phrase",
        "detail": "practice.PYTHON.58 - messageFromBinaryCode",
        "documentation": {}
    },
    {
        "label": "spiralNumbers",
        "kind": 2,
        "importPath": "practice.PYTHON.59 - spiralNumbers",
        "description": "practice.PYTHON.59 - spiralNumbers",
        "peekOfCode": "def spiralNumbers(n):\n    dims = n\n    elem = 1\n    matrix = [[0] * n for x in range(n)]\n    while 0 < dims:\n        i = n - dims\n        # you can sub i = n - dims ONLY in the first 2 parts\n        # where n - dims is in the starting parameter of the range\n        for j in range(n - dims, dims):\n            matrix[i][j] = elem",
        "detail": "practice.PYTHON.59 - spiralNumbers",
        "documentation": {}
    },
    {
        "label": "sudoku",
        "kind": 2,
        "importPath": "practice.PYTHON.60 - Sudoku",
        "description": "practice.PYTHON.60 - Sudoku",
        "peekOfCode": "def sudoku(grid):\n    for i in range(0, 9):\n        if sorted(grid[i]) != list(range(1, 10)):\n            return False\n    for j in range(0, 9):\n        if sorted(grid[y][j] for y in range(9)) != list(range(1, 10)):\n            return False\n    for i in range(0, 9, 3):\n        for j in range(0, 9, 3):\n            if sorted(",
        "detail": "practice.PYTHON.60 - Sudoku",
        "documentation": {}
    },
    {
        "label": "sudoku",
        "kind": 2,
        "importPath": "practice.PYTHON.60 - Sudoku",
        "description": "practice.PYTHON.60 - Sudoku",
        "peekOfCode": "def sudoku(grid):\n    def invalid_rows(x):\n        return sorted(grid[x]) != list(range(1, 10))\n    def invalid_cols(y):\n        return sorted(grid[x][y] for x in range(9)) != list(range(1, 10))\n    def invalid_subgr(a, b):\n        return sorted(\n            grid[x][y] for x in range(a, a + 3) for y in range(b, b + 3)\n        ) != list(range(1, 10))\n    for i in range(0, 9):",
        "detail": "practice.PYTHON.60 - Sudoku",
        "documentation": {}
    },
    {
        "label": "add",
        "kind": 2,
        "importPath": "practice.PYTHON.add",
        "description": "practice.PYTHON.add",
        "peekOfCode": "def add(param1, param2):\n    return param1 + param2",
        "detail": "practice.PYTHON.add",
        "documentation": {}
    },
    {
        "label": "addTwoDigits",
        "kind": 5,
        "importPath": "practice.PYTHON.addTwoDigits",
        "description": "practice.PYTHON.addTwoDigits",
        "peekOfCode": "addTwoDigits = lambda n: n % 10 + n // 10\n# return sum(int(i) for i in str(n))",
        "detail": "practice.PYTHON.addTwoDigits",
        "documentation": {}
    },
    {
        "label": "L,",
        "kind": 5,
        "importPath": "practice.PYTHON.arrayConsecutive",
        "description": "practice.PYTHON.arrayConsecutive",
        "peekOfCode": "L, = eval(dir()[0])\ns = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
        "detail": "practice.PYTHON.arrayConsecutive",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "practice.PYTHON.arrayConsecutive",
        "description": "practice.PYTHON.arrayConsecutive",
        "peekOfCode": "s = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
        "detail": "practice.PYTHON.arrayConsecutive",
        "documentation": {}
    },
    {
        "label": "L,",
        "kind": 5,
        "importPath": "practice.PYTHON.arrayConversion",
        "description": "practice.PYTHON.arrayConversion",
        "peekOfCode": "L, = eval(dir()[0])\ns = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
        "detail": "practice.PYTHON.arrayConversion",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "practice.PYTHON.arrayConversion",
        "description": "practice.PYTHON.arrayConversion",
        "peekOfCode": "s = 0\nwhile len(L) > 1:\n    L = (\n        numpy.add(L[:-1:2], L[1::2])\n        if s % 2 == 0\n        else numpy.multiply(L[:-1:2], L[1::2])\n    )\n    s += 1\nreturn L[0]",
        "detail": "practice.PYTHON.arrayConversion",
        "documentation": {}
    },
    {
        "label": "caseUnification",
        "kind": 2,
        "importPath": "practice.PYTHON.caseUnification",
        "description": "practice.PYTHON.caseUnification",
        "peekOfCode": "def caseUnification(s):\n    u = sum(1 for x in s if x.isupper())\n    if u > (len(s) / 2):\n        return s.upper()\n    else:\n        return s.lower()",
        "detail": "practice.PYTHON.caseUnification",
        "documentation": {}
    },
    {
        "label": "checkPalindrome",
        "kind": 5,
        "importPath": "practice.PYTHON.checkPalindrome",
        "description": "practice.PYTHON.checkPalindrome",
        "peekOfCode": "checkPalindrome = lambda x: x == x[::-1]",
        "detail": "practice.PYTHON.checkPalindrome",
        "documentation": {}
    },
    {
        "label": "n,",
        "kind": 5,
        "importPath": "practice.PYTHON.columnTitle",
        "description": "practice.PYTHON.columnTitle",
        "peekOfCode": "n, = eval(dir()[0])\nr = \"\"\nwhile n:\n    n -= 1\n    r = chr(n % 26 + 65) + r\n    n //= 26\nreturn r",
        "detail": "practice.PYTHON.columnTitle",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "practice.PYTHON.columnTitle",
        "description": "practice.PYTHON.columnTitle",
        "peekOfCode": "r = \"\"\nwhile n:\n    n -= 1\n    r = chr(n % 26 + 65) + r\n    n //= 26\nreturn r",
        "detail": "practice.PYTHON.columnTitle",
        "documentation": {}
    },
    {
        "label": "cubeVolume",
        "kind": 5,
        "importPath": "practice.PYTHON.cubeVolume",
        "description": "practice.PYTHON.cubeVolume",
        "peekOfCode": "cubeVolume = lambda n: n ** 3",
        "detail": "practice.PYTHON.cubeVolume",
        "documentation": {}
    },
    {
        "label": "depositProfit",
        "kind": 2,
        "importPath": "practice.PYTHON.depositProfit",
        "description": "practice.PYTHON.depositProfit",
        "peekOfCode": "def depositProfit(deposit, rate, threshold):\n    i = 0\n    while deposit < threshold:\n        deposit += deposit * rate * 0.01\n        i += 1\n    return i",
        "detail": "practice.PYTHON.depositProfit",
        "documentation": {}
    },
    {
        "label": "findTheRemainder",
        "kind": 2,
        "importPath": "practice.PYTHON.findTheRemainder",
        "description": "practice.PYTHON.findTheRemainder",
        "peekOfCode": "def findTheRemainder(a, b):\n    return a % b",
        "detail": "practice.PYTHON.findTheRemainder",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "practice.PYTHON.fractionComparison",
        "description": "practice.PYTHON.fractionComparison",
        "peekOfCode": "r = (a * d) / (b * c)\nreturn \"<\" if r < 1 else \">\" if r > 1 else \"=\"\n# 72 chars",
        "detail": "practice.PYTHON.fractionComparison",
        "documentation": {}
    },
    {
        "label": "f,",
        "kind": 5,
        "importPath": "practice.PYTHON.fractionReducing",
        "description": "practice.PYTHON.fractionReducing",
        "peekOfCode": "f, = eval(dir()[0])\nreturn [i / math.gcd(f[0], f[1]) for i in f]",
        "detail": "practice.PYTHON.fractionReducing",
        "documentation": {}
    },
    {
        "label": "gasPrediction",
        "kind": 5,
        "importPath": "practice.PYTHON.gasPrediction",
        "description": "practice.PYTHON.gasPrediction",
        "peekOfCode": "gasPrediction = lambda d, c, a: sum(d) / 12 / a > c",
        "detail": "practice.PYTHON.gasPrediction",
        "documentation": {}
    },
    {
        "label": "greetPerson",
        "kind": 5,
        "importPath": "practice.PYTHON.greetPerson",
        "description": "practice.PYTHON.greetPerson",
        "peekOfCode": "greetPerson = \"Hello, {}\".format",
        "detail": "practice.PYTHON.greetPerson",
        "documentation": {}
    },
    {
        "label": "halvingSum",
        "kind": 2,
        "importPath": "practice.PYTHON.halvingSum",
        "description": "practice.PYTHON.halvingSum",
        "peekOfCode": "def halvingSum(n):\n    s = 0\n    while n:\n        s += n\n        n //= 2\n    return s\n# s (int) : Sum\n# n (int) : Input number",
        "detail": "practice.PYTHON.halvingSum",
        "documentation": {}
    },
    {
        "label": "isAdult",
        "kind": 5,
        "importPath": "practice.PYTHON.isAdult",
        "description": "practice.PYTHON.isAdult",
        "peekOfCode": "isAdult = lambda a, m: a >= m",
        "detail": "practice.PYTHON.isAdult",
        "documentation": {}
    },
    {
        "label": "isSum",
        "kind": 2,
        "importPath": "practice.PYTHON.isSum",
        "description": "practice.PYTHON.isSum",
        "peekOfCode": "def isSum(value):\n    s = 0\n    for i in range(100):\n        s += i\n        if s == value:\n            return True",
        "detail": "practice.PYTHON.isSum",
        "documentation": {}
    },
    {
        "label": "isSuspiciousRespondent",
        "kind": 2,
        "importPath": "practice.PYTHON.isSuspiciousRespondent",
        "description": "practice.PYTHON.isSuspiciousRespondent",
        "peekOfCode": "def isSuspiciousRespondent(ans1, ans2, ans3):\n    return ans1 == ans2 == ans3",
        "detail": "practice.PYTHON.isSuspiciousRespondent",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "practice.PYTHON.lrcSubrip",
        "description": "practice.PYTHON.lrcSubrip",
        "peekOfCode": "r = []\nc = 1\nt = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
        "detail": "practice.PYTHON.lrcSubrip",
        "documentation": {}
    },
    {
        "label": "c",
        "kind": 5,
        "importPath": "practice.PYTHON.lrcSubrip",
        "description": "practice.PYTHON.lrcSubrip",
        "peekOfCode": "c = 1\nt = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
        "detail": "practice.PYTHON.lrcSubrip",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "practice.PYTHON.lrcSubrip",
        "description": "practice.PYTHON.lrcSubrip",
        "peekOfCode": "t = [[int(s[i : i + 2]) for i in [1, 4]] + [s[7:9]] for s in l]\nt = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
        "detail": "practice.PYTHON.lrcSubrip",
        "documentation": {}
    },
    {
        "label": "t",
        "kind": 5,
        "importPath": "practice.PYTHON.lrcSubrip",
        "description": "practice.PYTHON.lrcSubrip",
        "peekOfCode": "t = [f\"{x // 60:02d}:{x % 60:02d}:{y:02d},{z.ljust(3, str(0))}\" for x, y, z in t] + [\n    s + \",000\"\n]  # if I replace str(0) with '0', this increases to 359 characters wtf\nfor a, b in enumerate(l):\n    r.extend([str(c), t[a] + \" --> \" + t[a + 1], b[11:], \"\"])\n    c += 1\nreturn r[:-1]",
        "detail": "practice.PYTHON.lrcSubrip",
        "documentation": {}
    },
    {
        "label": "magicalWell",
        "kind": 2,
        "importPath": "practice.PYTHON.magicalWell",
        "description": "practice.PYTHON.magicalWell",
        "peekOfCode": "def magicalWell(a, b, n):\n    s, m = 0, 0\n    while m < n:\n        s += a * b\n        a += 1\n        b += 1\n        m += 1\n    return s",
        "detail": "practice.PYTHON.magicalWell",
        "documentation": {}
    },
    {
        "label": "a,",
        "kind": 5,
        "importPath": "practice.PYTHON.makeArrayConsecutive",
        "description": "practice.PYTHON.makeArrayConsecutive",
        "peekOfCode": "a, = eval(dir()[0])\nreturn [i for i in range(min(a), max(a)) if i not in a]",
        "detail": "practice.PYTHON.makeArrayConsecutive",
        "documentation": {}
    },
    {
        "label": "maxSubarray",
        "kind": 2,
        "importPath": "practice.PYTHON.maxSubarray",
        "description": "practice.PYTHON.maxSubarray",
        "peekOfCode": "def maxSubarray(A):\n    # A: inputArray\n    # m: Max\n    #\n    #\n    m = e = 0\n    for i in A:\n        e += i\n        if e < 0:\n            e = 0",
        "detail": "practice.PYTHON.maxSubarray",
        "documentation": {}
    },
    {
        "label": "mySubstring",
        "kind": 5,
        "importPath": "practice.PYTHON.mySubstring",
        "description": "practice.PYTHON.mySubstring",
        "peekOfCode": "mySubstring = lambda s, l, r: s[l : r + 1]",
        "detail": "practice.PYTHON.mySubstring",
        "documentation": {}
    },
    {
        "label": "passwordCheck",
        "kind": 5,
        "importPath": "practice.PYTHON.passwordCheck",
        "description": "practice.PYTHON.passwordCheck",
        "peekOfCode": "passwordCheck = lambda s: len(s) > 4 and all(\n    re.search(i, s) for i in (\"[A-Z]\", \"\\d\", \"[a-z]\")\n)",
        "detail": "practice.PYTHON.passwordCheck",
        "documentation": {}
    },
    {
        "label": "partition",
        "kind": 2,
        "importPath": "practice.PYTHON.quicksort",
        "description": "practice.PYTHON.quicksort",
        "peekOfCode": "def partition(A, lo, hi):\n    pivot = A[lo + (hi - lo) // 2]\n    i = lo - 1\n    j = hi + 1\n    while True:\n        i += 1\n        while A[i] < pivot:\n            i += 1\n        j -= 1\n        while A[j] > pivot:",
        "detail": "practice.PYTHON.quicksort",
        "documentation": {}
    },
    {
        "label": "quicksort",
        "kind": 2,
        "importPath": "practice.PYTHON.quicksort",
        "description": "practice.PYTHON.quicksort",
        "peekOfCode": "def quicksort(A, lo, hi):\n    if lo < hi:\n        p = partition(A, lo, hi)\n        quicksort(A, lo, p)\n        quicksort(A, p + 1, hi)\n    return A\nif __name__ == \"__main__\":\n    arr = [8, 3, 5, 1, 7, 2]\n    quicksort(arr, 0, len(arr) - 1)\n    # >>> [1, 2, 3, 5, 7, 8]",
        "detail": "practice.PYTHON.quicksort",
        "documentation": {}
    },
    {
        "label": "returnTwelve",
        "kind": 5,
        "importPath": "practice.PYTHON.returnTwelve",
        "description": "practice.PYTHON.returnTwelve",
        "peekOfCode": "returnTwelve = lambda n: 12 if n < 12 else n",
        "detail": "practice.PYTHON.returnTwelve",
        "documentation": {}
    },
    {
        "label": "r",
        "kind": 5,
        "importPath": "practice.PYTHON.runnersMeetings",
        "description": "practice.PYTHON.runnersMeetings",
        "peekOfCode": "r = -1\nl = len(p)\nfor i in range(l):\n    for j in range(l):\n        c = 0\n        d = p[j] - p[i]\n        f = s[i] - s[j]\n        if d * f < 1:\n            continue\n        for k in range(l):",
        "detail": "practice.PYTHON.runnersMeetings",
        "documentation": {}
    },
    {
        "label": "l",
        "kind": 5,
        "importPath": "practice.PYTHON.runnersMeetings",
        "description": "practice.PYTHON.runnersMeetings",
        "peekOfCode": "l = len(p)\nfor i in range(l):\n    for j in range(l):\n        c = 0\n        d = p[j] - p[i]\n        f = s[i] - s[j]\n        if d * f < 1:\n            continue\n        for k in range(l):\n            if p[k] * f + s[k] * d == p[i] * f + s[i] * d:",
        "detail": "practice.PYTHON.runnersMeetings",
        "documentation": {}
    },
    {
        "label": "smallestMultiple",
        "kind": 2,
        "importPath": "practice.PYTHON.smallestMultiple",
        "description": "practice.PYTHON.smallestMultiple",
        "peekOfCode": "def smallestMultiple(l, r):\n    for i in range(1, 16):\n        for j in range(l, r + 1):\n            while True:\n                if i % j != 0:\n                    break\n            return i",
        "detail": "practice.PYTHON.smallestMultiple",
        "documentation": {}
    },
    {
        "label": "A,",
        "kind": 5,
        "importPath": "practice.PYTHON.sortByHeight",
        "description": "practice.PYTHON.sortByHeight",
        "peekOfCode": "A, = numpy.r_[eval(dir()[0])]\nA[A > 0] = sorted(A[A > 0])\nreturn A",
        "detail": "practice.PYTHON.sortByHeight",
        "documentation": {}
    },
    {
        "label": "sulkyBoy",
        "kind": 5,
        "importPath": "practice.PYTHON.sulkyBoy",
        "description": "practice.PYTHON.sulkyBoy",
        "peekOfCode": "sulkyBoy = lambda x: not x",
        "detail": "practice.PYTHON.sulkyBoy",
        "documentation": {}
    },
    {
        "label": "sumOfSquares",
        "kind": 2,
        "importPath": "practice.PYTHON.sumOfSquares",
        "description": "practice.PYTHON.sumOfSquares",
        "peekOfCode": "def sumOfSquares(n):\n    return sum([x ** 2 for x in range(1, n + 1)])",
        "detail": "practice.PYTHON.sumOfSquares",
        "documentation": {}
    },
    {
        "label": "sumOfTheAngles",
        "kind": 5,
        "importPath": "practice.PYTHON.sumOfTheAngles",
        "description": "practice.PYTHON.sumOfTheAngles",
        "peekOfCode": "sumOfTheAngles = lambda n: (n - 2) * 180\n# n = eval(dir()[0])\n# return (n - 2) * 180",
        "detail": "practice.PYTHON.sumOfTheAngles",
        "documentation": {}
    },
    {
        "label": "sumOfTwo",
        "kind": 2,
        "importPath": "practice.PYTHON.sumOfTwo",
        "description": "practice.PYTHON.sumOfTwo",
        "peekOfCode": "def sumOfTwo(a, b, v):\n    b = set(b)\n    return any(v - i in b for i in a)",
        "detail": "practice.PYTHON.sumOfTwo",
        "documentation": {}
    },
    {
        "label": "visitsOnCircularRoad",
        "kind": 2,
        "importPath": "practice.PYTHON.visitsOnCircularRoad",
        "description": "practice.PYTHON.visitsOnCircularRoad",
        "peekOfCode": "def visitsOnCircularRoad(n, v):\n    c = 1\n    t = 0\n    for i in v:\n        t += min(abs(i - c), abs(n - abs(i - c)))\n        c = i\n    return t\n# v = visitsOrder\n# n = number of houses\n# c = Current position",
        "detail": "practice.PYTHON.visitsOnCircularRoad",
        "documentation": {}
    },
    {
        "label": "regularMonths",
        "kind": 2,
        "importPath": "practice.regularMondays.solution",
        "description": "practice.regularMondays.solution",
        "peekOfCode": "def regularMonths(c):\n    m, y = map(int, c.split(\"-\"))\n    while y:\n        for m in range(m + 1, 12 + 1):\n            if w(y, m, 1) == 0:\n                return f\"{str(m).zfill(2)}-{y}\"\n        m, y = 0, y + 1\nprint(regularMonths(\"07-2024\"))",
        "detail": "practice.regularMondays.solution",
        "documentation": {}
    },
    {
        "label": "isSentenceCorrect",
        "kind": 2,
        "importPath": "practice.reIsCorrect.solution",
        "description": "practice.reIsCorrect.solution",
        "peekOfCode": "def isSentenceCorrect(sentence):\n    pattern = \"^[A-Z][^?!.]*[?.!]$\"\n    return re.match(pattern, sentence) is not None\nprint(isSentenceCorrect(\"This is an example of *correct* sentence!\"))",
        "detail": "practice.reIsCorrect.solution",
        "documentation": {}
    },
    {
        "label": "reverseInParentheses",
        "kind": 2,
        "importPath": "practice.reverseInBract.solution",
        "description": "practice.reverseInBract.solution",
        "peekOfCode": "def reverseInParentheses(s):\n    \"\"\"\n    takes in a string that has substrings inside Parentheses, return a string with all substrings inside the Parentheses\n    reversed\n    \"\"\"\n    stack = []\n    for i in s:\n        if i == \")\":\n            ind = len(stack) - 1\n            while stack[ind] != \"(\":",
        "detail": "practice.reverseInBract.solution",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "practice.reverseInteger.solution",
        "description": "practice.reverseInteger.solution",
        "peekOfCode": "s = set()\ns.add(123)\ns.add(123)\nprint(s)",
        "detail": "practice.reverseInteger.solution",
        "documentation": {}
    },
    {
        "label": "rodCutting",
        "kind": 2,
        "importPath": "practice.rodCutting.solution",
        "description": "practice.rodCutting.solution",
        "peekOfCode": "def rodCutting(n, v):\n    a = v\n    for _ in a:\n        a = list(map(max, a, (a[0] + y for y in v)))\n        x = a.pop(0)\n    return x\nn = 4\nv = [0, 2, 4, 7, 7]\nprint(rodCutting(n, v))",
        "detail": "practice.rodCutting.solution",
        "documentation": {}
    },
    {
        "label": "n",
        "kind": 5,
        "importPath": "practice.rodCutting.solution",
        "description": "practice.rodCutting.solution",
        "peekOfCode": "n = 4\nv = [0, 2, 4, 7, 7]\nprint(rodCutting(n, v))",
        "detail": "practice.rodCutting.solution",
        "documentation": {}
    },
    {
        "label": "v",
        "kind": 5,
        "importPath": "practice.rodCutting.solution",
        "description": "practice.rodCutting.solution",
        "peekOfCode": "v = [0, 2, 4, 7, 7]\nprint(rodCutting(n, v))",
        "detail": "practice.rodCutting.solution",
        "documentation": {}
    },
    {
        "label": "rotateImage",
        "kind": 2,
        "importPath": "practice.rotateImage.solution",
        "description": "practice.rotateImage.solution",
        "peekOfCode": "def rotateImage(a):\n    if a == None:\n        return None\n    a.reverse()\n    for i in range(len(a)):\n        for j in range(i):\n            a[i][j], a[j][i] = a[j][i], a[i][j]\n    return a\nmat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(rotateImage(mat))",
        "detail": "practice.rotateImage.solution",
        "documentation": {}
    },
    {
        "label": "mat",
        "kind": 5,
        "importPath": "practice.rotateImage.solution",
        "description": "practice.rotateImage.solution",
        "peekOfCode": "mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(rotateImage(mat))",
        "detail": "practice.rotateImage.solution",
        "documentation": {}
    },
    {
        "label": "sensorsDifferenceSum",
        "kind": 2,
        "importPath": "practice.sensorsDifference.solution",
        "description": "practice.sensorsDifference.solution",
        "peekOfCode": "def sensorsDifferenceSum(sensor_1, sensor_2):\n    \"\"\"\n    given two lists contains the reading of two sensors for the same place, give the total difference between\n    there elements\n    \"\"\"\n    if len(sensor_1) == 0 or len(sensor_2) == 0:\n        return 0\n    return abs(sensor_1[0] - sensor_2[0]) + sensorsDifferenceSum(\n        sensor_1[1:], sensor_2[1:]\n    )",
        "detail": "practice.sensorsDifference.solution",
        "documentation": {}
    },
    {
        "label": "shortestSubstring",
        "kind": 2,
        "importPath": "practice.slidingWindow.solution",
        "description": "practice.slidingWindow.solution",
        "peekOfCode": "def shortestSubstring(s):\n    diff_chars, start, big = len(set(s)), 0, len(s)\n    end = diff_chars\n    while end <= len(s):\n        curr = len(set(s[start:end]))\n        if curr == diff_chars:\n            if end - start < big:\n                big = end - start\n            start += 1\n        else:",
        "detail": "practice.slidingWindow.solution",
        "documentation": {}
    },
    {
        "label": "stepPerms",
        "kind": 2,
        "importPath": "practice.stepPrem.solution",
        "description": "practice.stepPrem.solution",
        "peekOfCode": "def stepPerms(n):\n    \"\"\"\n    given n number of stairs, determine the total number of ways to climb the\n    stairs if you can take 1, 2, or 3 steps at a time\n    \"\"\"\n    if n < 0:\n        return 0\n    if n == 0:\n        return 1\n    else:",
        "detail": "practice.stepPrem.solution",
        "documentation": {}
    },
    {
        "label": "stepPermsDP",
        "kind": 2,
        "importPath": "practice.stepPrem.solution",
        "description": "practice.stepPrem.solution",
        "peekOfCode": "def stepPermsDP(n):\n    \"\"\"\n    given n number of stairs, determine the total number of ways to climb the\n    stairs if you can take 1, 2, or 3 steps at a time\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n < 0:\n        return 0\n    if n == 0:",
        "detail": "practice.stepPrem.solution",
        "documentation": {}
    },
    {
        "label": "memo",
        "kind": 5,
        "importPath": "practice.stepPrem.solution",
        "description": "practice.stepPrem.solution",
        "peekOfCode": "memo = {}\ndef stepPermsDP(n):\n    \"\"\"\n    given n number of stairs, determine the total number of ways to climb the\n    stairs if you can take 1, 2, or 3 steps at a time\n    \"\"\"\n    if n in memo:\n        return memo[n]\n    if n < 0:\n        return 0",
        "detail": "practice.stepPrem.solution",
        "documentation": {}
    },
    {
        "label": "almostIncreasingSequence",
        "kind": 2,
        "importPath": "practice.StrictlyIncreasingSequence.solution",
        "description": "practice.StrictlyIncreasingSequence.solution",
        "peekOfCode": "def almostIncreasingSequence(sequence):\n    for ind in range(len(sequence) - 1):\n        if sequence[ind] < sequence[ind + 1]:\n            continue\n        else:\n            if sequence.count(sequence[ind + 1]) > 1:\n                sequence.pop(ind + 1)\n            else:\n                sequence.pop(ind + 1)\n        return sequence == sorted(list(set(sequence)))",
        "detail": "practice.StrictlyIncreasingSequence.solution",
        "documentation": {}
    },
    {
        "label": "stringPermutations",
        "kind": 2,
        "importPath": "practice.stringPermutations.solution",
        "description": "practice.stringPermutations.solution",
        "peekOfCode": "def stringPermutations(s):\n    return sorted(list({\"\".join(itm) for itm in permutations(s)}))\nprint(stringPermutations(\"CDA\"))",
        "detail": "practice.stringPermutations.solution",
        "documentation": {}
    },
    {
        "label": "subarraySum",
        "kind": 2,
        "importPath": "practice.subarray_sum.solution",
        "description": "practice.subarray_sum.solution",
        "peekOfCode": "def subarraySum(nums, k):\n    \"\"\"\n    Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\n    \"\"\"\n    count = 0\n    s = 0\n    for i in range(len(nums)):\n        s += nums[i]\n        if s % k == 0:\n            count += 1",
        "detail": "practice.subarray_sum.solution",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "practice.subarray_sum.solution",
        "description": "practice.subarray_sum.solution",
        "peekOfCode": "nums = [1, 2, 3]\nk = 3\nprint(subarraySum(nums, k))",
        "detail": "practice.subarray_sum.solution",
        "documentation": {}
    },
    {
        "label": "k",
        "kind": 5,
        "importPath": "practice.subarray_sum.solution",
        "description": "practice.subarray_sum.solution",
        "peekOfCode": "k = 3\nprint(subarraySum(nums, k))",
        "detail": "practice.subarray_sum.solution",
        "documentation": {}
    },
    {
        "label": "sudoku2",
        "kind": 2,
        "importPath": "practice.sudoku2.solution",
        "description": "practice.sudoku2.solution",
        "peekOfCode": "def sudoku2(grid):\n    \"\"\"\n    check if sudoku board is true by checking that the same number didn't appear more than one in its row, col,\n    surrounding 3*3 sub matrix\n    \"\"\"\n    for i in range(9):\n        for j in range(9):\n            if i % 3 == 0 and j % 3 == 0:\n                l = [\n                    grid[s_i][s_j]",
        "detail": "practice.sudoku2.solution",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 5,
        "importPath": "practice.sudoku2.solution",
        "description": "practice.sudoku2.solution",
        "peekOfCode": "grid = [\n    [\".\", \".\", \"5\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \"8\", \".\", \".\", \".\", \"3\", \".\"],\n    [\".\", \"5\", \".\", \".\", \"2\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \"9\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \"4\", \".\", \".\"],\n    [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \"7\"],\n    [\".\", \"1\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\n    [\"2\", \"4\", \".\", \".\", \".\", \".\", \"9\", \".\", \".\"],",
        "detail": "practice.sudoku2.solution",
        "documentation": {}
    },
    {
        "label": "swapDiagonals",
        "kind": 2,
        "importPath": "practice.swapDiagonals.solution",
        "description": "practice.swapDiagonals.solution",
        "peekOfCode": "def swapDiagonals(matrix):\n    j = len(matrix) - 1\n    for i in range(len(matrix) // 2):\n        matrix[i][i], matrix[i][j - i] = matrix[i][j - i], matrix[i][i]\n        matrix[j - i][j - i], matrix[j - i][i] = matrix[j - i][i], matrix[j - i][j - i]\n    return matrix\nmatrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(swapDiagonals(matrix))",
        "detail": "practice.swapDiagonals.solution",
        "documentation": {}
    },
    {
        "label": "matrix",
        "kind": 5,
        "importPath": "practice.swapDiagonals.solution",
        "description": "practice.swapDiagonals.solution",
        "peekOfCode": "matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint(swapDiagonals(matrix))",
        "detail": "practice.swapDiagonals.solution",
        "documentation": {}
    },
    {
        "label": "swapAdjacentWords",
        "kind": 2,
        "importPath": "practice.swapWords.solution",
        "description": "practice.swapWords.solution",
        "peekOfCode": "def swapAdjacentWords(s):\n    return re.sub(r\"(\\w+) (\\w+)\", r\"\\2 \\1\", s)\ns = \"How are you guys?\"\nprint(swapAdjacentWords(s))",
        "detail": "practice.swapWords.solution",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "practice.swapWords.solution",
        "description": "practice.swapWords.solution",
        "peekOfCode": "s = \"How are you guys?\"\nprint(swapAdjacentWords(s))",
        "detail": "practice.swapWords.solution",
        "documentation": {}
    },
    {
        "label": "countPalindromes",
        "kind": 2,
        "importPath": "practice.totalPalindrome.solution",
        "description": "practice.totalPalindrome.solution",
        "peekOfCode": "def countPalindromes(s):\n    \"\"\"\n    countPalindromes(s) takes in a string s and returns the number of palindrome in the string\n    :param s: a string\n    :return: number of palindrome sub strings\n    \"\"\"\n    tot_pal = len(s)\n    for i in range(len(s)):\n        tot_pal += helper(s, i, i + 1)\n        tot_pal += helper(s, i - 1, i + 1)",
        "detail": "practice.totalPalindrome.solution",
        "documentation": {}
    },
    {
        "label": "helper",
        "kind": 2,
        "importPath": "practice.totalPalindrome.solution",
        "description": "practice.totalPalindrome.solution",
        "peekOfCode": "def helper(s, l, r):\n    tot = 0\n    while (l >= 0) and (r < len(s)) and (s[l] == s[r]):\n        tot += 1\n        l -= 1\n        r += 1\n    return tot\nprint(countPalindromes(\"aaa\"))",
        "detail": "practice.totalPalindrome.solution",
        "documentation": {}
    },
    {
        "label": "twoSum",
        "kind": 2,
        "importPath": "practice.twoSum.solution",
        "description": "practice.twoSum.solution",
        "peekOfCode": "def twoSum(nums, target):\n    \"\"\"\n    Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n    h = {}\n    for i, v in enumerate(nums):\n        if v in h:\n            return [h[v], i]\n        else:",
        "detail": "practice.twoSum.solution",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "practice.twoSum.solution",
        "description": "practice.twoSum.solution",
        "peekOfCode": "nums = [2, 7, 11, 15]\ntarget = 9\nprint(twoSum(nums, target))",
        "detail": "practice.twoSum.solution",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "practice.twoSum.solution",
        "description": "practice.twoSum.solution",
        "peekOfCode": "target = 9\nprint(twoSum(nums, target))",
        "detail": "practice.twoSum.solution",
        "documentation": {}
    },
    {
        "label": "twoPointerSum",
        "kind": 2,
        "importPath": "practice.twoSum.twoPointerSolution",
        "description": "practice.twoSum.twoPointerSolution",
        "peekOfCode": "def twoPointerSum(nums, target):\n    \"\"\"\n    Given a sorted array of integers, return indices of the two numbers such that they add up to a specific target.\n    You may assume that each input would have exactly one solution, and you may not use the same element twice.\n    \"\"\"\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        if nums[l] + nums[r] == target:\n            return [l, r]",
        "detail": "practice.twoSum.twoPointerSolution",
        "documentation": {}
    },
    {
        "label": "nums",
        "kind": 5,
        "importPath": "practice.twoSum.twoPointerSolution",
        "description": "practice.twoSum.twoPointerSolution",
        "peekOfCode": "nums = [5, 25, 75]\ntarget = 100\nprint(twoPointerSum(nums, target))",
        "detail": "practice.twoSum.twoPointerSolution",
        "documentation": {}
    },
    {
        "label": "target",
        "kind": 5,
        "importPath": "practice.twoSum.twoPointerSolution",
        "description": "practice.twoSum.twoPointerSolution",
        "peekOfCode": "target = 100\nprint(twoPointerSum(nums, target))",
        "detail": "practice.twoSum.twoPointerSolution",
        "documentation": {}
    },
    {
        "label": "BinaryTreeNode",
        "kind": 6,
        "importPath": "practice.demonstration_1 copy",
        "description": "practice.demonstration_1 copy",
        "peekOfCode": "class BinaryTreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\ndef maxDepth(root):\n    # Your code here\n    if root.left is None and root.right is None:\n        # this is a leaf so depth is just 1\n        return 1",
        "detail": "practice.demonstration_1 copy",
        "documentation": {}
    },
    {
        "label": "maxDepth",
        "kind": 2,
        "importPath": "practice.demonstration_1 copy",
        "description": "practice.demonstration_1 copy",
        "peekOfCode": "def maxDepth(root):\n    # Your code here\n    if root.left is None and root.right is None:\n        # this is a leaf so depth is just 1\n        return 1\n    left_depth = 0\n    right_depth = 0\n    if root.left:\n        left_depth = maxDepth(root.left)\n    if root.right:",
        "detail": "practice.demonstration_1 copy",
        "documentation": {}
    },
    {
        "label": "pivot_index",
        "kind": 2,
        "importPath": "practice.demonstration_1",
        "description": "practice.demonstration_1",
        "peekOfCode": "def pivot_index(nums):  # == 2*O(n) = O(n)\n    # Your code here\n    curr = 0\n    l_sum = 0\n    r_sum = sum(nums)  # O(n)\n    for i in range(len(nums)):  # O(n)\n        # l_sum = sum(nums[0:i])   #all in the loop is O(n)\n        # r_sum = sum(nums[i +1:])\n        # remove current value from r_sum\n        r_sum -= nums[i]",
        "detail": "practice.demonstration_1",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "practice.demonstration_2 copy",
        "description": "practice.demonstration_2 copy",
        "peekOfCode": "class TreeNode:\n    def __init__(self, value=0, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\ndef is_valid_BST(root):\n    # Your code here\n    if root is None:\n        return False\n    if root.left is None and root.right is None:",
        "detail": "practice.demonstration_2 copy",
        "documentation": {}
    },
    {
        "label": "is_valid_BST",
        "kind": 2,
        "importPath": "practice.demonstration_2 copy",
        "description": "practice.demonstration_2 copy",
        "peekOfCode": "def is_valid_BST(root):\n    # Your code here\n    if root is None:\n        return False\n    if root.left is None and root.right is None:\n        return False\n    if root.left.value < root.value:\n        is_valid_BST(root.left)\n    if root.right.value > root.value:\n        is_valid_BST(root.right)",
        "detail": "practice.demonstration_2 copy",
        "documentation": {}
    },
    {
        "label": "plus_one",
        "kind": 2,
        "importPath": "practice.demonstration_2",
        "description": "practice.demonstration_2",
        "peekOfCode": "def plus_one(digits):\n    # Your code here\n    new_string = \"\"\n    for digit in digits:\n        new_digit = str(digit)\n        new_string += new_digit\n    print(new_string)\n    str_tonum = int(new_string)\n    str_tonum = str_tonum + 1\n    str_tonum = str(str_tonum)",
        "detail": "practice.demonstration_2",
        "documentation": {}
    },
    {
        "label": "BSTNode",
        "kind": 6,
        "importPath": "practice.guided",
        "description": "practice.guided",
        "peekOfCode": "class BSTNode:\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n    def insert(self, value):\n        # create a node for the new value\n        new_node = BSTNode(value)\n        # compare the node value to the self value\n        if (",
        "detail": "practice.guided",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "practice.guided",
        "description": "practice.guided",
        "peekOfCode": "root = BSTNode(10)\n# root.left = BSTNode(6)\n# root.right = BSTNode(12)\nroot.insert(6)\nroot.insert(7)\nroot.insert(12)\nroot.insert(5)\nroot.insert(14)\nroot.insert(8)\nprint(f\"minimum value in tree is: {root.find_minimum_value()}\")",
        "detail": "practice.guided",
        "documentation": {}
    },
    {
        "label": "schoolGroups",
        "kind": 2,
        "importPath": "practice.module2-lastTask",
        "description": "practice.module2-lastTask",
        "peekOfCode": "def schoolGroups(years, groups):\n    alphabet = list(map(chr, range(97, 123)))\n    emp_list = []\n    for year in range(1, years + 1):\n        for group in range(0, groups):\n            emp_list.append(f\"{year}{alphabet[group]}\")\n    # print(emp_list)\n    return \", \".join(emp_list)\nprint(schoolGroups(1, 4))\nprint(schoolGroups(6, 7))",
        "detail": "practice.module2-lastTask",
        "documentation": {}
    },
    {
        "label": "csAnythingButFive",
        "kind": 2,
        "importPath": "practice.module2-projects",
        "description": "practice.module2-projects",
        "peekOfCode": "def csAnythingButFive(start, end):\n    count = 0\n    new_list = []\n    for num in range(start, end + 1):\n        str_num = str(num)\n        if \"5\" in str_num:\n            continue\n        count += 1\n    return count\nprint(csAnythingButFive(1, 5))",
        "detail": "practice.module2-projects",
        "documentation": {}
    }
]